// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum GuildMemberRank {
  S
  A
  B
  C
  D
  E // Default rank
}

enum RelationshipType {
  PARENT // Defines a hierarchical relationship where sourceGuildId is parent, targetGuildId is child
  PARTNER
  RIVAL
  // WAR // Example for future unilateral type
}

enum ContactType {
  WEBSITE
  EMAIL
  DISCORD
  TWITTER
  BLUESKY
  TWITCH
  GITHUB
  LINKEDIN
  CUSTOM
}

enum BadgeShape {
  CIRCLE
  STAR
  HEART
  HEXAGON
  SQUARE // Added
}

enum BadgeTier {
  GOLD
  SILVER
  BRONZE
}

// --- Configuration Enums (for validating badge display properties) ---

enum BackgroundContentType {
  SOLID_COLOR     // The 'value' will be a hex color string.
  HOSTED_IMAGE    // The 'value' will be a hostedUrl from an UploadedAsset.
}

enum ForegroundContentType {
  TEXT            // The 'value' will be a string of text.
  SYSTEM_ICON     // The 'value' will be an id or unique name referencing a SystemIcon record.
  UPLOADED_ICON   // The 'value' will be a hostedUrl from an UploadedAsset (typically an SVG or small raster icon).
}

// Optional: Describes a predefined visual style for text elements.
// enum TextStyle {
//   METADATA_DEFAULT
//   METADATA_HIGHLIGHT
//   FOREGROUND_TITLE
// }
// --- END Configuration Enums ---

enum NotificationType {
  GUILD_INVITE
  BADGE_RECEIVED
  GUILD_JOIN_REQUEST
  RELATIONSHIP_REQUEST // This might be deprecated or reused for general relationship updates
  GUILD_UPDATE
  NEW_GUILD_MEMBER
  ROLE_ASSIGNED
  RANK_UPDATED
  CATEGORY_PRIMARY_SET

  // Guild Relationship Proposal Notifications
  GUILD_RELATIONSHIP_PROPOSAL_RECEIVED
  GUILD_RELATIONSHIP_PROPOSAL_ACCEPTED
  GUILD_RELATIONSHIP_PROPOSAL_REJECTED
  GUILD_RELATIONSHIP_PROPOSAL_REVOKED
  GUILD_RELATIONSHIP_PROPOSAL_EXPIRED
  // Add more as new features arise
}

// --- Guild Invitation System Enums ---
enum GuildInvitationStatus {
  PENDING // Invitation sent, awaiting response
  ACCEPTED // Invitation accepted, user is now a member or will be processed as one
  REJECTED // Invitation explicitly rejected by the target
  EXPIRED // Invitation expired due to time limit (if applicable)
  REVOKED // Invitation withdrawn by guild admin/owner
  CONSUMED // Invitation automatically processed (e.g., due to new social link or joining via another means)
}

enum InvitationPlatform {
  VIAGUILD // ViaGuild username
  TWITTER
  BLUESKY
  TWITCH
  DISCORD
  // EMAIL // Potentially for future use
  // OTHER // Generic for unlisted platforms
}

enum GuildJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- Cluster Invitation/Join Request System Enums ---
enum ClusterDirectInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED
  EXPIRED // Optional: if cluster-to-guild invites can expire
}

enum RelationshipProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED // By the proposer
  EXPIRED
  SUPERSEDED // When another proposal between the same guilds is accepted
}

enum ClusterJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- NEW ENUM for Badge Instance Acceptance Status ---
enum BadgeAwardStatus {
  PENDING_ACCEPTANCE // Newly awarded, receiver hasn't acknowledged/accepted
  ACCEPTED           // Receiver has accepted the badge into their collection
  REJECTED           // Receiver has explicitly rejected the badge
}


// --- CORE MODELS ---

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  email_ci       String   @unique // Case-insensitive version for uniqueness and lookup
  username       String   @unique // Unique handle
  username_ci    String   @unique // Case-insensitive version for uniqueness and lookup
  displayName    String? // For display purposes
  passwordHash   String
  bio            String?
  avatar         String? // Current: Base64/file path. Future: hostedUrl from UploadedAsset
  isPublic       Boolean  @default(true)
  hiddenAccounts String[] @default([]) // Array of social account IDs to hide
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships - Permissions & Roles
  systemRoles UserSystemRole[]

  // Relationships - Social & Guilds
  socialAccounts   SocialAccount[]
  createdGuilds    Guild[]           @relation("GuildCreator")
  updatedGuilds    Guild[]           @relation("GuildUpdater") // Guilds last updated by this user
  guildMemberships GuildMembership[]
  // createdRelationships GuildRelationship[] @relation("RelationshipCreator") // Guild relationships created by this user // REMOVED

  // Guild Relationships - as proposer or accepter
  proposedGuildRelationships GuildRelationship[] @relation("RelationshipProposer")
  acceptedGuildRelationships GuildRelationship[] @relation("RelationshipAccepter")

  // Guild Relationship Proposals - as initiator or resolver
  initiatedGuildRelationshipProposals GuildRelationshipProposal[] @relation("ProposedByUser")
  resolvedGuildRelationshipProposals  GuildRelationshipProposal[] @relation("ResolvedByUser")

  // --- BADGE SYSTEM RELATIONS (Updated) ---
  givenBadgesAsUser      BadgeInstance[]       @relation("UserGivenBadges") // Badges given directly by this user
  receivedBadgesAsUser   BadgeInstance[]       @relation("UserReceivedBadges") // Badges received directly by this user
  authoredBadgeTemplates BadgeTemplate[]       @relation("AuthoredByRelation") // Templates authored by this user
  ownedBadgeTemplates    BadgeTemplate[]       @relation("UserOwnedBadgeTemplates")
  badgeAllocations       UserBadgeAllocation[] // Tiered badge allocations for this user
  badgeCase              UserBadgeCase?
  uploadedAssets         UploadedAsset[]       @relation("UserUploadedAssets")
  // --- END BADGE SYSTEM RELATIONS ---

  // Relationships - Categories
  primaryGuildsPerCategory UserCategoryPrimaryGuild[] // User's designated primary guilds for specific categories
  // createdCategories         Category[]              @relation("UserCreatedCategories") // If users can create categories

  // Relationships - Notifications
  notifications      Notification[] @relation("NotificationRecipient")
  actorNotifications Notification[] @relation("NotificationActor") // Notifications where this user was the actor

  // Add these relations
  bansReceived GuildBan[] @relation("BannedUser")
  bansIssued   GuildBan[] @relation("BanIssuer")

  // Relations for audit trails (who assigned what)
  rolePermissionsAssigned       RolePermission[]         @relation("RolePermissionAssignedBy")
  systemRolesAssigned           UserSystemRole[]         @relation("UserSystemRoleAssignedBy")
  guildBadgeAssignmentsActioned GuildAssignmentDetails[] @relation("GuildAssignmentDetailsAssignedBy")
  guildCategoriesAssigned       GuildCategory[]          @relation("GuildCategoryAssignedBy")

  // Relationships - Clusters
  createdClusters Cluster[]         @relation("ClusterCreator")
  clusterRoles    UserClusterRole[] // Roles held by the user in various clusters

  // Relationships - Guild Invitations & Join Requests
  sentGuildDirectInvitations     GuildDirectInvitation[] @relation("Inviter")
  receivedGuildDirectInvitations GuildDirectInvitation[] @relation("InvitedUser")
  createdGuildInvitationLinks    GuildInvitationLink[]   @relation("LinkCreator")
  guildJoinRequests              GuildJoinRequest[]      @relation("Requester")
  reviewedGuildJoinRequests      GuildJoinRequest[]      @relation("Reviewer")

  // Relationships - Cluster Invitations & Join Requests (as initiator/reviewer)
  sentClusterDirectInvitations ClusterDirectInvitation[] @relation("ClusterInviter")
  initiatedClusterJoinRequests ClusterJoinRequest[]      @relation("ClusterJoinRequester")
  reviewedClusterJoinRequests  ClusterJoinRequest[]      @relation("ClusterJoinRequestReviewer")
}

model SocialAccount {
  id                   String   @id @default(uuid())
  provider             String // "twitter", "bluesky", "twitch", "discord"
  providerId           String // ID from the provider
  username             String // Username from the provider
  username_ci          String?  // Case-insensitive version for searching. Nullable to match original if username can be null. Assuming username is not nullable based on usage.
  encryptedCredentials String? // Encrypted app password or OAuth token for future use (e.g. posting on their behalf)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
  @@index([username_ci]) // Index for case-insensitive searches
}

model Guild {
  id                String   @id @default(uuid())
  name              String   @unique // Unique handle/slug for the guild
  name_ci           String   @unique // Case-insensitive version for uniqueness
  displayName       String? // For display purposes
  description       String   @db.Text
  avatar            String? // Current: URL to image storage. Future: hostedUrl from UploadedAsset
  isOpen            Boolean  @default(false) // If true, users can join automatically without needing permission/invitation.
  allowJoinRequests Boolean  @default(true) // If true, users can submit requests to join this guild (moderated).
  createdById       String
  updatedById       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationships - Creator/Updater
  creator   User  @relation("GuildCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy User? @relation("GuildUpdater", fields: [updatedById], references: [id], onDelete: SetNull)

  // Relationships - Members & Structure
  memberships GuildMembership[]
  roles       Role[]            @relation("GuildCustomRoles") // Custom roles defined for THIS guild
  contacts    GuildContact[]
  roleDisplayPreferences GuildRoleDisplayPreference[] // For guild-specific role display order

  // --- BADGE SYSTEM RELATIONS (Updated) ---
  givenBadgesAsGuild    BadgeInstance[] @relation("GuildGivenBadges") // Badges given by this guild as an entity
  receivedBadgesAsGuild BadgeInstance[] @relation("GuildReceivedBadges") // Badges received by this guild as an entity
  ownedBadgeTemplates   BadgeTemplate[] @relation("GuildOwnedBadgeTemplates") // Badge templates "owned" or designed by this guild
  badgeCase             GuildBadgeCase? // Guild's showcase of received badges
  // --- END BADGE SYSTEM RELATIONS ---

  // Relationships - Inter-Guild
  outgoingRelationships GuildRelationship[] @relation("SourceRelationships")
  incomingRelationships GuildRelationship[] @relation("TargetRelationships")

  // Relationships - Inter-Guild Proposals
  sentRelationshipProposals     GuildRelationshipProposal[] @relation("ProposingGuildForRelationship")
  receivedRelationshipProposals GuildRelationshipProposal[] @relation("TargetGuildForRelationship")

  // Relationships - Categories
  categories                    GuildCategory[] // Categories this guild belongs to
  designatedAsPrimaryInCategory UserCategoryPrimaryGuild[] // Instances where this guild is marked primary for a category by users

  // Relationships - Clusters
  primaryClusterId   String?             @unique // Optional: A guild can have one primary cluster
  primaryCluster     Cluster?            @relation("PrimaryClusterForGuilds", fields: [primaryClusterId], references: [id], onDelete: SetNull)
  clusterMemberships ClusterMembership[] // Guilds that are members of this cluster

  // Add this relation
  bans GuildBan[]

  // Relationships - Guild Invitations & Join Requests
  directInvitations GuildDirectInvitation[] @relation("InvitedToGuild")
  invitationLinks   GuildInvitationLink[]   @relation("LinkForGuild")
  joinRequests      GuildJoinRequest[]      @relation("RequestToGuild")

  // Relationships - Cluster System (as target of invite or requester of join)
  receivedClusterDirectInvitations ClusterDirectInvitation[] @relation("TargetGuildForClusterInvitation")
  sentClusterJoinRequests          ClusterJoinRequest[]      @relation("RequestingGuildForClusterJoin")

  @@index([name])
  @@index([primaryClusterId])
}

// --- PERMISSION SYSTEM ---
model Permission {
  id              String   @id @default(cuid())
  key             String   @unique // e.g., "GUILD_KICK_MEMBER", "BADGE_TEMPLATE_CREATE_GUILD"
  description     String?
  permissionGroup String? // For UI grouping, e.g., "Guild Management", "Badge Administration"
  createdAt       DateTime @default(now())

  rolePermissions        RolePermission[]
  clusterRolePermissions ClusterRolePermission[]

  @@index([key])
}

model Role {
  id            String   @id @default(cuid())
  name          String // e.g., "Founder", "Admin", "Member", "Treasurer", "SuperAdmin"
  name_ci       String   // Case-insensitive version of name
  description   String?
  guildId       String? // If null, it's a system-level role. If set, it's a custom role for that specific guild.
  isSystemRole  Boolean  @default(false) // True for ViaGuild predefined roles (Founder, Admin, Member, SuperAdmin)
  isDefaultRole Boolean  @default(false) // e.g., new guild members get this role by default for their guild
  
  displayColor String?  @default("##20C3D5") @map("display_color") // Default to #20C3D5. Optional: Hex color code (e.g., "#FF5733") for this role
  apiVisible   Boolean  @default(false) @map("api_visible") // If true, this role assignment can be queried by APIs.

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  guild            Guild?            @relation("GuildCustomRoles", fields: [guildId], references: [id], onDelete: Cascade)
  permissions      RolePermission[]
  assignedUserGuildRoles UserGuildRole[]   // Relation to the join table
  systemUsers      UserSystemRole[]
  guildDisplayPreferences GuildRoleDisplayPreference[] // NEW: Back-relation

  @@unique([guildId, name_ci], name: "unique_guild_role_name_ci")
  @@index([guildId])
  @@index([apiVisible]) // Index for the new flag
}

model RolePermission {
  id           String   @id @default(cuid())
  roleId       String
  permissionId String
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this permission to the role (for auditing)

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy User?      @relation("RolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserSystemRole {
  id           String   @id @default(cuid())
  userId       String
  roleId       String // Must be a Role where guildId is null and isSystemRole is true
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this system role

  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role  @relation(fields: [roleId], references: [id], onDelete: Cascade) // Should point to a system role
  assignedBy User? @relation("UserSystemRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// --- GUILD STRUCTURE & MEMBERSHIP ---
model GuildMembership {
  id           String          @id @default(uuid())
  userId       String
  guildId      String
  isPrimary    Boolean         @default(false) // Global primary guild for the user
  primarySetAt DateTime? // When this guild was set as primary
  rank         GuildMemberRank @default(E)
  joinedAt     DateTime        @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([userId, guildId], name: "uniqueUserGuildMembership") // Name clarified

  // New relation to the roles this membership holds
  assignedRoles UserGuildRole[]

  @@index([userId])
  @@index([guildId])
  @@index([userId, isPrimary])
}

// NEW JOIN TABLE: UserGuildRole
model UserGuildRole {
  id                String   @id @default(cuid())
  guildMembershipId String
  roleId            String
  assignedAt        DateTime @default(now())
  // assignedByUserId String? // Optional: User who assigned this specific role to the member

  guildMembership GuildMembership @relation(fields: [guildMembershipId], references: [id], onDelete: Cascade)
  role            Role            @relation(fields: [roleId], references: [id], onDelete: Restrict) // Don't delete Role if in use here
  // assignedBy   User?        @relation("RoleAssignedToMemberBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@unique([guildMembershipId, roleId]) // A member can only have a specific role once in a guild
  @@index([guildMembershipId])
  @@index([roleId])
  // @@index([assignedByUserId])
}

model GuildRelationship {
  id             String           @id @default(uuid())
  sourceGuildId  String
  targetGuildId  String
  type           RelationshipType
  // createdById   String // User who created the relationship // REMOVED
  proposerUserId String? // User who initiated the proposal or unilateral action
  accepterUserId String? // User who accepted a proposal; nullable for unilateral actions
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  sourceGuild  Guild @relation("SourceRelationships", fields: [sourceGuildId], references: [id], onDelete: Cascade)
  targetGuild  Guild @relation("TargetRelationships", fields: [targetGuildId], references: [id], onDelete: Cascade)
  // creator     User  @relation("RelationshipCreator", fields: [createdById], references: [id], onDelete: Restrict) // REMOVED
  proposerUser User? @relation("RelationshipProposer", fields: [proposerUserId], references: [id], onDelete: SetNull)
  accepterUser User? @relation("RelationshipAccepter", fields: [accepterUserId], references: [id], onDelete: SetNull)

  @@unique([sourceGuildId, targetGuildId])
  @@index([sourceGuildId])
  @@index([targetGuildId])
}

model GuildContact {
  id           String      @id @default(uuid())
  guildId      String
  type         ContactType
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, displayOrder])
}

// --- BADGE SYSTEM (REVISED with Tables Solution) ---

model BadgeTemplate {
  id                          String  @id @default(uuid())
  templateSlug                String  // NEW: Immutable, machine-friendly unique key for this template type, scoped by owner.
  templateSlug_ci             String  // Case-insensitive version
  internalNotes               String? @db.Text // Internal notes about template purpose

  // Ownership and Creation (of the template)
  authoredByUserId            String? 
  authoredByUser              User?   @relation("AuthoredByRelation", fields: [authoredByUserId], references: [id], onDelete: SetNull)
  ownedByUserId               String?
  ownedByUser                 User?   @relation("UserOwnedBadgeTemplates", fields: [ownedByUserId], references: [id], onDelete: SetNull)
  ownedByGuildId              String?
  ownedByGuild                Guild?  @relation("GuildOwnedBadgeTemplates", fields: [ownedByGuildId], references: [id], onDelete: SetNull)

  // Lifecycle & Behavior
  isArchived                  Boolean @default(false) // Whether the template owner has archived/soft-deleted this template (it is not deleted from the db if there exist awarded badge instances with this template)
  isModifiableByIssuer        Boolean @default(false) // Can this template be modified? (changes propagate to non-overridden properties of awarded badges)
  allowsPushedInstanceUpdates Boolean @default(false) // Can the issuer modify individual instances of this badge post-award?

  // --- Tier Configuration ---
  inherentTier                BadgeTier? // Renamed from defaultTier. Optional: The inherent tier of this template, influences allocation use & can enforce/suggest styling (e.g., border color).

  // --- Default Display Properties (Effectively the "Display Config" embedded) ---
  defaultBadgeName              String   // Default display name
  defaultSubtitleText           String?  // Default subtitle text
  defaultOuterShape             BadgeShape @default(CIRCLE)
  defaultBorderColor            String     @default("#000000") // Hex
  defaultBackgroundType         BackgroundContentType @default(SOLID_COLOR)
  defaultBackgroundValue        String     // Hex color or HostedAsset.hostedUrl
  defaultForegroundType         ForegroundContentType @default(SYSTEM_ICON)
  defaultForegroundValue        String     // Text, SystemIcon.id, or HostedAsset.hostedUrl
  defaultForegroundColor        String?    // Hex
  defaultTextFont               String?    // If foreground type is TEXT (from approved list)
  defaultTextSize               Int?       // If foreground type is TEXT (e.g., in pixels)
  defaultDisplayDescription     String?    @db.Text // Default user-facing description for this badge type

  // --- Programmatic Credential Configuration ---
  definesCredential             Boolean @default(false) // Does this template type utilize BadgeInstance.credentialValue?
  credentialLabel               String? // How to label this metric if shown, e.g., "Rank", "Security Level"
  credentialBest                Float?  // Numeric value representing the best possible score/rank
  credentialWorst               Float?  // Numeric value representing the worst possible score/rank
  // (Interpretation: if credentialWorst > credentialBest, lower is better; if credentialBest > credentialWorst, higher is better)
  credentialNotes               String? // e.g. the credentialValue represents xyz and is calculated in such and such way
  credentialIsNormalizable      Boolean @default(false) // Hints if the credentialValue can be normalized from 0 to 1
  
  metadataFieldDefinitions MetadataFieldDefinition[] // Defines slots for displayable textual metadata
  instances                BadgeInstance[]
  
  createdAt                DateTime        @default(now())
  updatedAt                DateTime        @updatedAt

  @@index([authoredByUserId])
  @@index([ownedByUserId])
  @@index([ownedByGuildId])
  @@index([isArchived])
  @@index([isModifiableByIssuer])
  @@index([allowsPushedInstanceUpdates])
  @@index([inherentTier])

  @@unique([ownedByUserId, templateSlug_ci], name: "unique_user_template_slug_ci")
  @@unique([ownedByGuildId, templateSlug_ci], name: "unique_guild_template_slug_ci")
  // Note: For system templates (ownedByUserId=null, ownedByGuildId=null), 
  // uniqueness of templateSlug needs to be ensured by application/seeding logic (e.g. prefixing with "system_")
  // or by making templateSlug globally @unique if preferred (but then requires globally unique names from users/guilds too).
  // The current setup with scoped uniques is generally more flexible for user/guild created templates.
}

// Defines a slot for DISPLAYABLE instance-specific textual metadata
model MetadataFieldDefinition {
  id                      String  @id @default(uuid())
  badgeTemplateId         String  // Foreign key to BadgeTemplate
  badgeTemplate           BadgeTemplate @relation(fields: [badgeTemplateId], references: [id], onDelete: Cascade)

  fieldKeyForInstanceData String  // The key used in `InstanceMetadataValue.dataKey`
  label                   String  // e.g., "Date Achieved:", "Score:"
  prefix                  String?
  suffix                  String?
  style                   String? // e.g., "METADATA_DEFAULT", maps to CSS/UI styling
  displayOrder            Int     @default(0)

  @@unique([badgeTemplateId, fieldKeyForInstanceData])
  @@index([badgeTemplateId, displayOrder])
}

model BadgeInstance {
  id         String    @id @default(uuid())
  templateId String
  template   BadgeTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  // --- Giver (Polymorphic: User or Guild) ---
  userGiverId  String?
  userGiver    User?   @relation("UserGivenBadges", fields: [userGiverId], references: [id], onDelete: SetNull)
  guildGiverId String?
  guildGiver   Guild?  @relation("GuildGivenBadges", fields: [guildGiverId], references: [id], onDelete: SetNull)

  // --- Receiver (Polymorphic: User or Guild or Cluster) ---
  userReceiverId    String?
  userReceiver      User?     @relation("UserReceivedBadges", fields: [userReceiverId], references: [id], onDelete: Cascade)
  guildReceiverId   String?
  guildReceiver     Guild?    @relation("GuildReceivedBadges", fields: [guildReceiverId], references: [id], onDelete: Cascade)
  clusterReceiverId String? 
  clusterReceiver   Cluster?  @relation("ClusterReceivedBadges", fields: [clusterReceiverId], references: [id], onDelete: Cascade)

  assignedAt DateTime  @default(now())
  revokedAt  DateTime?
  message    String?   @db.Text

  // --- Direct, Typed Fields for Core Visual Overrides (Nullable) ---
  overrideBadgeName        String?
  overrideSubtitle         String?
  overrideOuterShape       BadgeShape?
  overrideBorderColor      String?    // Hex
  overrideBackgroundType   BackgroundContentType?
  overrideBackgroundValue  String?    // Hex or HostedAsset.hostedUrl
  overrideForegroundType   ForegroundContentType?
  overrideForegroundValue  String?    // Text, SystemIcon.id, or HostedAsset.hostedUrl
  overrideForegroundColor  String?    // Hex
  overrideTextFont         String?
  overrideTextSize         Int?
  overrideDisplayDescription String? @db.Text

  // --- Dedicated Field for Programmatic Credential Value ---
  credentialValue          Float? // This value is the metric used for programmatic checks.

  // --- Instance Status & API Visibility ---
  awardStatus              BadgeAwardStatus @default(PENDING_ACCEPTANCE) // Status of the badge award itself
  apiVisible               Boolean          @default(false) // Receiver-controlled: if true, this badge is visible to API/programmatic checks. Set to true upon acceptance, can be toggled by receiver.

  // --- Link to Instance-Specific DISPLAYABLE METADATA Values ---
  metadataValues InstanceMetadataValue[] // Stores values for fields defined in MetadataFieldDefinition

  guildAssignmentDetails GuildAssignmentDetails? @relation("BadgeInstanceToGuildAssignmentDetails")

  // Links to Badge Case Items
  userBadgeItem          UserBadgeItem?          // Link to badgecase where this badge instance is displayed
  guildBadgeItems        GuildBadgeItem[]        // Link to badgecases where this badge instance is displayed
  clusterBadgeItems      ClusterBadgeItem[]      // Link to badgecases where this badge instance is displayed


  // CHECK constraint (conceptual, enforce in application logic):
  // 1. (userGiverId != null XOR guildGiverId != null XOR clusterGiverId != null) // Consider clusterGiver later
  // 2. (userReceiverId != null XOR guildReceiverId != null XOR clusterReceiverId != null)
  // 3. If guildGiverId is set, detailsOfGuildAssignmentId can be set.
  //    (The link is via GuildAssignmentDetails.badgeInstanceId pointing to this BadgeInstance.id)

  @@index([templateId])
  @@index([userGiverId])
  @@index([guildGiverId])
  @@index([userReceiverId])
  @@index([guildReceiverId])
  @@index([clusterReceiverId])
  @@index([credentialValue])
  @@index([awardStatus])
  @@index([apiVisible])
}

// Stores the actual key-value pairs for DISPLAYABLE textual metadata for a specific BadgeInstance
model InstanceMetadataValue {
  id               String  @id @default(uuid())
  badgeInstanceId  String
  badgeInstance    BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  // This `dataKey` MUST match a `fieldKeyForInstanceData` from one of the
  // BadgeInstance's template's associated MetadataFieldDefinitions.
  dataKey          String  // e.g., "dateAchieved", "playerScore", "reasonForAward"
  dataValue        String  // Actual metadata value (application logic parses if needed)

  @@unique([badgeInstanceId, dataKey])
  @@index([badgeInstanceId])
}

model GuildAssignmentDetails {
  id              String        @id @default(uuid())
  badgeInstanceId String        @unique // Link back to the BadgeInstance
  badgeInstance   BadgeInstance @relation("BadgeInstanceToGuildAssignmentDetails", fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  assignmentMethod String? // e.g., "MEMBER_VOTE", "ADMIN_DECISION", "AUTOMATED_MILESTONE"
  voteRecordId     String? // If applicable, link to a vote record elsewhere
  approvalChain    Json? // Store who approved it, if a multi-step process
  notes            String? @db.Text
  assignedByUserId String? // User who actioned this guild assignment (if applicable)

  assignedByUser User? @relation("GuildAssignmentDetailsAssignedBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([badgeInstanceId])
}

model UserBadgeAllocation {
  id                String    @id @default(uuid())
  userId            String
  tier              BadgeTier
  remaining         Int       @default(0)
  lastReplenishedAt DateTime  @default(now())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([userId, tier])
  @@index([userId])
}

model UserBadgeCase {
  id        String   @id @default(uuid())
  userId    String   @unique
  title     String?
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  badges UserBadgeItem[]
}

model UserBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String   @unique
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())
  badgeCase UserBadgeCase @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge     BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model GuildBadgeCase {
  id              String   @id @default(uuid())
  guildId         String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique // Optional featured badge for special display
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  guild         Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)
  badges        GuildBadgeItem[]
  featuredBadge GuildBadgeItem?  @relation("FeaturedGuildBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model GuildBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())
  badgeCase  GuildBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance   @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn GuildBadgeCase? @relation("FeaturedGuildBadgeInCase") // Link back if this item is the featured one

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

// +++ NEW UPLOAD/ICON MODELS (as defined in schema4.prisma) +++
model UploadedAsset {
  id                 String    @id @default(cuid())
  uploaderId         String?   
  uploader           User?     @relation("UserUploadedAssets", fields: [uploaderId], references: [id], onDelete: SetNull)
  originalFilename   String?
  mimeType           String    
  sizeBytes          Int       
  hostedUrl          String    @unique 
  storageIdentifier  String    @unique 
  assetType          String    
  description        String?   
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  systemIconsAsAsset SystemIcon[] 

  @@index([uploaderId])
  @@index([assetType])
  @@index([hostedUrl])
}

model SystemIcon {
  id           String  @id @default(cuid()) 
  name         String  @unique              
  category     String?                     
  svgContent   String?                     
  assetId      String? @unique             
  asset        UploadedAsset? @relation(fields: [assetId], references: [id], onDelete: SetNull) 
  isAvailable  Boolean @default(true)      
  description  String?                     
  tags         String[]                    
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([name])
  @@index([category])
  @@index([isAvailable])
}
// --- END NEW UPLOAD/ICON MODELS ---

// --- GUILD CATEGORIES ---
model Category {
  id                 String   @id @default(cuid())
  name               String   @unique
  name_ci            String   @unique // Case-insensitive version for uniqueness
  description        String?
  isSystemCategory   Boolean  @default(false) // True if created by ViaGuild admins
  allowsGuildPrimary Boolean  @default(true) // True if users can mark a guild as 'primary' for this category
  parentId           String? // For hierarchical categories
  // creatorId           String?                 // User who created this category (if user-creatable)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  parent        Category?  @relation("SubCategories", fields: [parentId], references: [id], onDelete: SetNull)
  subcategories Category[] @relation("SubCategories")
  // creator             User?     @relation("UserCreatedCategories" fields: [creatorId], references: [id], onDelete:SetNull)

  guildsInCategories GuildCategory[] // Guilds associated with this category
  userPrimaryGuilds  UserCategoryPrimaryGuild[] // User designations of primary guilds in this category

  @@index([parentId])
}

model GuildCategory {
  guildId      String
  categoryId   String
  assignedAt   DateTime @default(now())
  assignedById String? // User ID of who assigned the guild to category (permission controlled)

  guild      Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  assignedBy User?    @relation("GuildCategoryAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@id([guildId, categoryId])
  @@index([guildId])
  @@index([categoryId])
}

model UserCategoryPrimaryGuild {
  userId     String
  categoryId String
  guildId    String // The guild the user has marked as primary for this category
  setAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  guild    Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  // User must be a member of guildId, guildId must be in categoryId, and category.allowsGuildPrimary must be true.
  @@id([userId, categoryId]) // A user can only have one primary guild per category
  @@index([userId])
  @@index([categoryId])
  @@index([guildId])
}

// --- NOTIFICATION SYSTEM ---
model Notification {
  id        String           @id @default(uuid())
  userId    String // The user who receives the notification
  type      NotificationType
  title     String
  content   String           @db.Text
  linkUrl   String? // URL to relevant page when notification is clicked
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Contextual information about the notification
  sourceId   String? // ID of related entity (guild, badge, user, etc.)
  sourceType String? // Type of source ("guild", "badgeInstance", "user", "category")
  actorId    String? // User who triggered the notification (if applicable)

  recipient User  @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  actor     User? @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, isRead])
  @@index([createdAt])
}

// --- GUILD BAN MODEL ---
model GuildBan {
  id             String    @id @default(uuid())
  guildId        String // The guild that issued the ban
  bannedUserId   String // The user who was banned
  bannedByUserId String // The user who issued the ban
  reason         String?   @db.Text // Optional reason for the ban
  expiresAt      DateTime? // Null means permanent ban
  isActive       Boolean   @default(true)
  notes          String?   @db.Text // Additional context or notes
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relationships
  guild      Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  bannedUser User  @relation("BannedUser", fields: [bannedUserId], references: [id], onDelete: Cascade)
  bannedBy   User  @relation("BanIssuer", fields: [bannedByUserId], references: [id], onDelete: Restrict)

  // Indexes for efficient querying
  @@unique([guildId, bannedUserId]) // A user can only be banned once per guild
  @@index([guildId])
  @@index([bannedUserId])
  @@index([bannedByUserId])
  @@index([isActive])
  @@index([expiresAt])
}

// --- CLUSTER SYSTEM ---

model Cluster {
  id          String   @id @default(uuid())
  name        String   @unique
  name_ci     String   @unique // Case-insensitive version for uniqueness
  displayName String?
  description String?  @db.Text
  avatar      String? // URL to image storage
  isOpen      Boolean  @default(false) // True if guilds can join without approval
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator User @relation("ClusterCreator", fields: [createdById], references: [id], onDelete: Restrict)

  // Relationships - Members & Structure
  guildMemberships ClusterMembership[] // Guilds that are members of this cluster
  roles            ClusterRole[]       @relation("ClusterCustomRoles") // Custom roles for this cluster
  userRoles        UserClusterRole[] // New: User roles within this cluster

  // Relationships - Primary Designation
  primaryForGuilds Guild[] @relation("PrimaryClusterForGuilds")

  // Relationships - Badges
  receivedBadgesAsCluster BadgeInstance[]   @relation("ClusterReceivedBadges") // Badges received by this cluster
  badgeCase               ClusterBadgeCase? // Cluster's showcase of received badges
  contacts                ClusterContact[] // New: Contact links for the cluster

  // Relationships - Cluster Invitations & Join Requests (as source)
  directInvitationsToGuilds ClusterDirectInvitation[] @relation("InvitingCluster")
  joinRequestsFromGuilds    ClusterJoinRequest[]      @relation("TargetClusterForJoinRequest")

  @@index([name])
}

model ClusterMembership {
  id        String   @id @default(uuid())
  guildId   String
  clusterId String
  joinedAt  DateTime @default(now())

  guild   Guild   @relation(fields: [guildId], references: [id], onDelete: Cascade)
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([guildId, clusterId])
  @@index([guildId])
  @@index([clusterId])
}

model ClusterRole {
  id           String   @id @default(cuid())
  name         String
  name_ci      String   // Case-insensitive version
  description  String?
  clusterId    String? // Link to the specific cluster, optional for system roles
  isSystemRole Boolean  @default(false) // e.g., CLUSTER_CREATOR, CLUSTER_ADMIN
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  cluster          Cluster?                @relation("ClusterCustomRoles", fields: [clusterId], references: [id], onDelete: Cascade) // Made Cluster optional
  permissions      ClusterRolePermission[] // Link to the permissions this cluster role has
  userClusterRoles UserClusterRole[]

  @@unique([clusterId, name_ci], name: "unique_cluster_role_name_ci")
  @@index([clusterId])
}

model UserClusterRole {
  id            String   @id @default(cuid())
  userId        String
  clusterId     String
  clusterRoleId String
  assignedAt    DateTime @default(now())
  // assignedById String? // User who assigned this cluster role

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cluster     Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("UserClusterRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, clusterId, clusterRoleId], name: "uniqueUserClusterRoleInCluster")
  @@index([userId])
  @@index([clusterId])
  @@index([clusterRoleId])
}

model ClusterBadgeCase {
  id              String   @id @default(uuid())
  clusterId       String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cluster       Cluster            @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  badges        ClusterBadgeItem[]
  featuredBadge ClusterBadgeItem?  @relation("FeaturedClusterBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model ClusterBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  ClusterBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance     @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn ClusterBadgeCase? @relation("FeaturedClusterBadgeInCase")

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model ClusterContact {
  id           String      @id @default(uuid())
  clusterId    String
  type         ContactType // Reusing the existing ContactType enum
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  @@index([clusterId, displayOrder])
}

model ClusterRolePermission {
  id            String   @id @default(cuid())
  clusterRoleId String
  permissionId  String
  assignedAt    DateTime @default(now())
  // assignedById  String?  // Optional: User who assigned this permission to the cluster role (for auditing)

  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  permission  Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("ClusterRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([clusterRoleId, permissionId])
  @@index([clusterRoleId])
  @@index([permissionId])
}


// --- GUILD INVITATION SYSTEM ---

model GuildDirectInvitation {
  id               String                @id @default(uuid())
  guildId          String
  invitedByUserId  String // User who sent the invitation
  targetUserId     String? // VG user who received the invitation (if they exist in ViaGuild system)
  targetUserHandle String // The handle/username used for the invitation (e.g. "username123", "user@example.com")
  targetUserHandle_ci String // Case-insensitive version
  platform         InvitationPlatform // Platform of the targetUserHandle (e.g. VIAGUILD, TWITTER, DISCORD, etc.)
  status           GuildInvitationStatus @default(PENDING)
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  expiresAt        DateTime? // Optional: For invitations that have a time limit

  guild         Guild @relation("InvitedToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  invitedByUser User  @relation("Inviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser    User? @relation("InvitedUser", fields: [targetUserId], references: [id], onDelete: SetNull) // Null if invited user is not yet on platform

  @@unique([guildId, targetUserHandle_ci, platform], name: "uniqueInvitationByHandle_ci")
  @@index([guildId])
  @@index([invitedByUserId])
  @@index([targetUserId])
  @@index([targetUserHandle, platform])
  @@index([status])
}

model GuildInvitationLink {
  id              String    @id @default(uuid()) // Can also be a unique string code if preferred over UUID
  guildId         String
  createdByUserId String
  code            String    @unique // The unique, shareable code for the link
  maxUses         Int? // Null for unlimited uses
  currentUses     Int       @default(0)
  expiresAt       DateTime? // Null for no expiration
  revokedAt       DateTime? // Timestamp if the link was manually revoked
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  guild         Guild @relation("LinkForGuild", fields: [guildId], references: [id], onDelete: Cascade)
  createdByUser User  @relation("LinkCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([createdByUserId])
  @@index([code])
}

model GuildJoinRequest {
  id               String                 @id @default(uuid())
  guildId          String
  userId           String // User requesting to join
  message          String?                @db.Text // Optional message from the user
  status           GuildJoinRequestStatus @default(PENDING)
  reviewedByUserId String? // Admin/Creator who reviewed the request
  reviewedAt       DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  guild          Guild @relation("RequestToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  requestingUser User  @relation("Requester", fields: [userId], references: [id], onDelete: Cascade)
  reviewedByUser User? @relation("Reviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([guildId, userId]) // User can only have one pending request per guild
  @@index([guildId])
  @@index([userId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- CLUSTER INVITATION & JOIN REQUEST SYSTEM ---

model ClusterDirectInvitation {
  id              String                        @id @default(uuid())
  clusterId       String // The cluster sending the invitation
  invitedByUserId String // User (cluster admin) who sent the invitation
  targetGuildId   String // The guild being invited
  status          ClusterDirectInvitationStatus @default(PENDING)
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime? // Optional: for invitations that have a time limit

  invitingCluster Cluster @relation("InvitingCluster", fields: [clusterId], references: [id], onDelete: Cascade)
  invitedByUser   User    @relation("ClusterInviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetGuild     Guild   @relation("TargetGuildForClusterInvitation", fields: [targetGuildId], references: [id], onDelete: Cascade)

  @@unique([clusterId, targetGuildId], name: "uniqueClusterToGuildInvitation")
  @@index([clusterId])
  @@index([invitedByUserId])
  @@index([targetGuildId])
  @@index([status])
}

model ClusterJoinRequest {
  id                String                   @id @default(uuid())
  clusterId         String // The cluster being requested to join
  requestingGuildId String // The guild making the request
  requestedByUserId String // User from the requesting guild who initiated the request
  message           String?                  @db.Text
  status            ClusterJoinRequestStatus @default(PENDING)
  reviewedByUserId  String? // User (cluster admin) who reviewed the request
  reviewedAt        DateTime?
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt

  targetCluster   Cluster @relation("TargetClusterForJoinRequest", fields: [clusterId], references: [id], onDelete: Cascade)
  requestingGuild Guild   @relation("RequestingGuildForClusterJoin", fields: [requestingGuildId], references: [id], onDelete: Cascade)
  requestedByUser User    @relation("ClusterJoinRequester", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  reviewedByUser  User?   @relation("ClusterJoinRequestReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([clusterId, requestingGuildId], name: "uniqueGuildToClusterJoinRequest")
  @@index([clusterId])
  @@index([requestingGuildId])
  @@index([requestedByUserId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- GUILD RELATIONSHIP PROPOSAL SYSTEM ---

model GuildRelationshipProposal {
  id                   String                     @id @default(uuid())
  proposingGuildId     String
  targetGuildId        String
  proposedType         RelationshipType
  status               RelationshipProposalStatus @default(PENDING)
  messageFromProposer  String?                    @db.Text
  messageFromResponder String?                    @db.Text
  proposedByUserId     String
  resolvedByUserId     String?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  expiresAt            DateTime?

  proposingGuild Guild @relation("ProposingGuildForRelationship", fields: [proposingGuildId], references: [id], onDelete: Cascade)
  targetGuild    Guild @relation("TargetGuildForRelationship", fields: [targetGuildId], references: [id], onDelete: Cascade)
  proposedByUser User  @relation("ProposedByUser", fields: [proposedByUserId], references: [id], onDelete: Cascade)
  resolvedByUser User? @relation("ResolvedByUser", fields: [resolvedByUserId], references: [id], onDelete: SetNull)
  @@unique([proposingGuildId, targetGuildId, proposedType, status], name: "unique_pending__guild_relationship_proposal")
  @@index([proposingGuildId])
  @@index([targetGuildId])
  @@index([status])
  @@index([proposedByUserId])
  @@index([resolvedByUserId])
}

// NEW MODEL: For guild-specific display order/preference of roles
model GuildRoleDisplayPreference {
  id              String  @id @default(cuid())
  guildId         String
  roleId          String  // Can be an ID of a system role OR a custom role for this guild
  displayPriority Int     // Lower number means higher priority (displays first)

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  role  Role  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@map("guild_role_display_preferences") // Map table name to plural
  @@unique([guildId, roleId]) // A role can only have one display preference per guild
  @@unique([guildId, displayPriority]) // Priority should be unique within a guild
  @@index([guildId, displayPriority]) // For fetching ordered roles for a guild
  @@index([roleId]) // For finding all guilds where a specific role has a preference
}
