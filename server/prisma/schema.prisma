// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum GuildMemberRank {
  S
  A
  B
  C
  D
  E // Default rank
}

enum RelationshipType {
  PARENT // Defines a hierarchical relationship where sourceGuildId is parent, targetGuildId is child
  PARTNER
  RIVAL
  // WAR // Example for future unilateral type
}

enum ContactType {
  WEBSITE
  EMAIL
  DISCORD
  TWITTER
  BLUESKY
  TWITCH
  GITHUB
  LINKEDIN
  CUSTOM
}

enum BadgeShape {
  CIRCLE
  STAR
  HEART
  HEXAGON
}

enum BadgeTier {
  GOLD
  SILVER
  BRONZE
}

enum NotificationType {
  GUILD_INVITE
  BADGE_RECEIVED
  GUILD_JOIN_REQUEST
  RELATIONSHIP_REQUEST // This might be deprecated or reused for general relationship updates
  GUILD_UPDATE
  NEW_GUILD_MEMBER
  ROLE_ASSIGNED
  RANK_UPDATED
  CATEGORY_PRIMARY_SET

  // Guild Relationship Proposal Notifications
  GUILD_RELATIONSHIP_PROPOSAL_RECEIVED
  GUILD_RELATIONSHIP_PROPOSAL_ACCEPTED
  GUILD_RELATIONSHIP_PROPOSAL_REJECTED
  GUILD_RELATIONSHIP_PROPOSAL_REVOKED
  GUILD_RELATIONSHIP_PROPOSAL_EXPIRED
  // Add more as new features arise
}

// --- Guild Invitation System Enums ---
enum GuildInvitationStatus {
  PENDING // Invitation sent, awaiting response
  ACCEPTED // Invitation accepted, user is now a member or will be processed as one
  REJECTED // Invitation explicitly rejected by the target
  EXPIRED // Invitation expired due to time limit (if applicable)
  REVOKED // Invitation withdrawn by guild admin/owner
  CONSUMED // Invitation automatically processed (e.g., due to new social link or joining via another means)
}

enum InvitationPlatform {
  VIAGUILD // ViaGuild username
  TWITTER
  BLUESKY
  TWITCH
  DISCORD
  // EMAIL // Potentially for future use
  // OTHER // Generic for unlisted platforms
}

enum GuildJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- Cluster Invitation/Join Request System Enums ---
enum ClusterDirectInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED
  EXPIRED // Optional: if cluster-to-guild invites can expire
}

enum RelationshipProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED // By the proposer
  EXPIRED
  SUPERSEDED // When another proposal between the same guilds is accepted
}

enum ClusterJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- CORE MODELS ---

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  username       String   @unique // Unique handle
  displayName    String? // For display purposes
  passwordHash   String
  bio            String?
  avatar         String? // Base64 encoded image data or file path
  isPublic       Boolean  @default(true)
  hiddenAccounts String[] @default([]) // Array of social account IDs to hide
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships - Permissions & Roles
  systemRoles UserSystemRole[]

  // Relationships - Social & Guilds
  socialAccounts   SocialAccount[]
  createdGuilds    Guild[]           @relation("GuildCreator")
  updatedGuilds    Guild[]           @relation("GuildUpdater") // Guilds last updated by this user
  guildMemberships GuildMembership[]
  // createdRelationships GuildRelationship[] @relation("RelationshipCreator") // Guild relationships created by this user // REMOVED

  // Guild Relationships - as proposer or accepter
  proposedGuildRelationships GuildRelationship[] @relation("RelationshipProposer")
  acceptedGuildRelationships GuildRelationship[] @relation("RelationshipAccepter")

  // Guild Relationship Proposals - as initiator or resolver
  initiatedGuildRelationshipProposals GuildRelationshipProposal[] @relation("ProposedByUser")
  resolvedGuildRelationshipProposals  GuildRelationshipProposal[] @relation("ResolvedByUser")

  // Relationships - Badges
  givenBadgesAsUser     BadgeInstance[]       @relation("UserGivenBadges") // Badges given directly by this user
  receivedBadgesAsUser  BadgeInstance[]       @relation("UserReceivedBadges") // Badges received directly by this user
  createdBadgeTemplates BadgeTemplate[]       @relation("UserCreatedTemplates") // Templates created by this user
  badgeAllocations      UserBadgeAllocation[] // Tiered badge allocations for this user
  badgeCase             UserBadgeCase? // User's personal showcase of received badges

  // Relationships - Categories
  primaryGuildsPerCategory UserCategoryPrimaryGuild[] // User's designated primary guilds for specific categories
  // createdCategories         Category[]              @relation("UserCreatedCategories") // If users can create categories

  // Relationships - Notifications
  notifications      Notification[] @relation("NotificationRecipient")
  actorNotifications Notification[] @relation("NotificationActor") // Notifications where this user was the actor

  // Add these relations
  bansReceived GuildBan[] @relation("BannedUser")
  bansIssued   GuildBan[] @relation("BanIssuer")

  // Relations for audit trails (who assigned what)
  rolePermissionsAssigned       RolePermission[]         @relation("RolePermissionAssignedBy")
  systemRolesAssigned           UserSystemRole[]         @relation("UserSystemRoleAssignedBy")
  guildBadgeAssignmentsActioned GuildAssignmentDetails[] @relation("GuildAssignmentDetailsAssignedBy")
  guildCategoriesAssigned       GuildCategory[]          @relation("GuildCategoryAssignedBy")

  // Relationships - Clusters
  createdClusters Cluster[]         @relation("ClusterCreator")
  clusterRoles    UserClusterRole[] // Roles held by the user in various clusters

  // Relationships - Guild Invitations & Join Requests
  sentGuildDirectInvitations     GuildDirectInvitation[] @relation("Inviter")
  receivedGuildDirectInvitations GuildDirectInvitation[] @relation("InvitedUser")
  createdGuildInvitationLinks    GuildInvitationLink[]   @relation("LinkCreator")
  guildJoinRequests              GuildJoinRequest[]      @relation("Requester")
  reviewedGuildJoinRequests      GuildJoinRequest[]      @relation("Reviewer")

  // Relationships - Cluster Invitations & Join Requests (as initiator/reviewer)
  sentClusterDirectInvitations ClusterDirectInvitation[] @relation("ClusterInviter")
  initiatedClusterJoinRequests ClusterJoinRequest[]      @relation("ClusterJoinRequester")
  reviewedClusterJoinRequests  ClusterJoinRequest[]      @relation("ClusterJoinRequestReviewer")
}

model SocialAccount {
  id                   String   @id @default(uuid())
  provider             String // "twitter", "bluesky", "twitch", "discord"
  providerId           String // ID from the provider
  username             String // Username from the provider
  encryptedCredentials String? // Encrypted app password or OAuth token for future use (e.g. posting on their behalf)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
}

model Guild {
  id                String   @id @default(uuid())
  name              String   @unique // Unique handle/slug for the guild
  displayName       String? // For display purposes
  description       String   @db.Text
  avatar            String? // URL to image storage
  isOpen            Boolean  @default(false) // If true, users can join automatically without needing permission/invitation.
  allowJoinRequests Boolean  @default(true) // If true, users can submit requests to join this guild (moderated).
  createdById       String
  updatedById       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationships - Creator/Updater
  creator   User  @relation("GuildCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy User? @relation("GuildUpdater", fields: [updatedById], references: [id], onDelete: SetNull)

  // Relationships - Members & Structure
  memberships GuildMembership[]
  roles       Role[]            @relation("GuildCustomRoles") // Custom roles defined for this guild
  contacts    GuildContact[]

  // Relationships - Badges
  givenBadgesAsGuild    BadgeInstance[] @relation("GuildGivenBadges") // Badges given by this guild as an entity
  receivedBadgesAsGuild BadgeInstance[] @relation("GuildReceivedBadges") // Badges received by this guild as an entity
  badgeTemplates        BadgeTemplate[] @relation("GuildOwnedTemplates") // Badge templates "owned" or designed by this guild
  badgeCase             GuildBadgeCase? // Guild's showcase of received badges

  // Relationships - Inter-Guild
  outgoingRelationships GuildRelationship[] @relation("SourceRelationships")
  incomingRelationships GuildRelationship[] @relation("TargetRelationships")

  // Relationships - Inter-Guild Proposals
  sentRelationshipProposals     GuildRelationshipProposal[] @relation("ProposingGuildForRelationship")
  receivedRelationshipProposals GuildRelationshipProposal[] @relation("TargetGuildForRelationship")

  // Relationships - Categories
  categories                    GuildCategory[] // Categories this guild belongs to
  designatedAsPrimaryInCategory UserCategoryPrimaryGuild[] // Instances where this guild is marked primary for a category by users

  // Relationships - Clusters
  primaryClusterId   String?             @unique // Optional: A guild can have one primary cluster
  primaryCluster     Cluster?            @relation("PrimaryClusterForGuilds", fields: [primaryClusterId], references: [id], onDelete: SetNull)
  clusterMemberships ClusterMembership[] // Guilds that are members of this cluster

  // Add this relation
  bans GuildBan[]

  // Relationships - Guild Invitations & Join Requests
  directInvitations GuildDirectInvitation[] @relation("InvitedToGuild")
  invitationLinks   GuildInvitationLink[]   @relation("LinkForGuild")
  joinRequests      GuildJoinRequest[]      @relation("RequestToGuild")

  // Relationships - Cluster System (as target of invite or requester of join)
  receivedClusterDirectInvitations ClusterDirectInvitation[] @relation("TargetGuildForClusterInvitation")
  sentClusterJoinRequests          ClusterJoinRequest[]      @relation("RequestingGuildForClusterJoin")

  @@index([name])
  @@index([primaryClusterId])
}

// --- PERMISSION SYSTEM ---

model Permission {
  id              String   @id @default(cuid())
  key             String   @unique // e.g., "GUILD_KICK_MEMBER", "BADGE_TEMPLATE_CREATE_GUILD"
  description     String?
  permissionGroup String? // For UI grouping, e.g., "Guild Management", "Badge Administration"
  createdAt       DateTime @default(now())

  rolePermissions        RolePermission[]
  clusterRolePermissions ClusterRolePermission[] // New: For cluster roles

  @@index([key])
}

model Role {
  id            String   @id @default(cuid())
  name          String // e.g., "Owner", "Admin", "Member", "Treasurer", "SuperAdmin"
  description   String?
  guildId       String? // If null, it's a system-level role. If set, it's a custom role for that specific guild.
  isSystemRole  Boolean  @default(false) // True for ViaGuild predefined roles (Owner, Admin, Member, SuperAdmin)
  isDefaultRole Boolean  @default(false) // e.g., new guild members get this role by default for their guild
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  guild            Guild?            @relation("GuildCustomRoles", fields: [guildId], references: [id], onDelete: Cascade)
  permissions      RolePermission[]
  guildMemberships GuildMembership[]
  systemUsers      UserSystemRole[]

  @@unique([name, guildId])
  @@index([guildId])
}

model RolePermission {
  id           String   @id @default(cuid())
  roleId       String
  permissionId String
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this permission to the role (for auditing)

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy User?      @relation("RolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserSystemRole {
  id           String   @id @default(cuid())
  userId       String
  roleId       String // Must be a Role where guildId is null and isSystemRole is true
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this system role

  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role  @relation(fields: [roleId], references: [id], onDelete: Cascade) // Should point to a system role
  assignedBy User? @relation("UserSystemRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// --- GUILD STRUCTURE & MEMBERSHIP ---

model GuildMembership {
  id           String          @id @default(uuid())
  userId       String
  guildId      String
  roleId       String // Points to an entry in the Role table
  isPrimary    Boolean         @default(false) // Global primary guild for the user
  primarySetAt DateTime? // When this guild was set as primary
  rank         GuildMemberRank @default(E)
  joinedAt     DateTime        @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  role  Role  @relation(fields: [roleId], references: [id], onDelete: Restrict) // Don't delete role if in use

  @@unique([userId, guildId], name: "uniqueUserGuild")
  @@index([userId])
  @@index([guildId])
  @@index([roleId])
  @@index([userId, isPrimary])
}

model GuildRelationship {
  id             String           @id @default(uuid())
  sourceGuildId  String
  targetGuildId  String
  type           RelationshipType
  // createdById   String // User who created the relationship // REMOVED
  proposerUserId String? // User who initiated the proposal or unilateral action
  accepterUserId String? // User who accepted a proposal; nullable for unilateral actions
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  sourceGuild  Guild @relation("SourceRelationships", fields: [sourceGuildId], references: [id], onDelete: Cascade)
  targetGuild  Guild @relation("TargetRelationships", fields: [targetGuildId], references: [id], onDelete: Cascade)
  // creator     User  @relation("RelationshipCreator", fields: [createdById], references: [id], onDelete: Restrict) // REMOVED
  proposerUser User? @relation("RelationshipProposer", fields: [proposerUserId], references: [id], onDelete: SetNull)
  accepterUser User? @relation("RelationshipAccepter", fields: [accepterUserId], references: [id], onDelete: SetNull)

  @@unique([sourceGuildId, targetGuildId])
  @@index([sourceGuildId])
  @@index([targetGuildId])
}

model GuildContact {
  id           String      @id @default(uuid())
  guildId      String
  type         ContactType
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, displayOrder])
}

// --- BADGE SYSTEM ---

model BadgeTemplate {
  id          String     @id @default(uuid())
  name        String
  description String?    @db.Text
  imageUrl    String?
  shapeType   BadgeShape @default(CIRCLE)
  borderColor String // Hex color code (#RRGGBB)
  tier        BadgeTier? // Optional: For default/global templates that might have a tier like UserBadgeAllocation
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Creator/Owner of the template
  creatorUserId  String? // User who created this template (if not guild-owned)
  ownedByGuildId String? // Guild that owns/designed this template (if not user-created)

  creatorUser  User?           @relation("UserCreatedTemplates", fields: [creatorUserId], references: [id], onDelete: SetNull)
  ownedByGuild Guild?          @relation("GuildOwnedTemplates", fields: [ownedByGuildId], references: [id], onDelete: SetNull)
  instances    BadgeInstance[]

  // A template should be either user-created or guild-owned, or system (both null)
  @@index([creatorUserId])
  @@index([ownedByGuildId])
}

model BadgeInstance {
  id         String    @id @default(uuid())
  templateId String
  assignedAt DateTime  @default(now()) // Renamed from givenAt
  revokedAt  DateTime?
  message    String? // Optional message from the giver or context of assignment

  // --- Giver (Polymorphic: User or Guild) ---
  userGiverId  String?
  guildGiverId String?
  // clusterGiverId String? // Future: If clusters can give badges

  // --- Receiver (Polymorphic: User or Guild or Cluster) ---
  userReceiverId    String?
  guildReceiverId   String?
  clusterReceiverId String? // New: Cluster as a receiver

  guildAssignmentDetails GuildAssignmentDetails? @relation("BadgeInstanceToGuildAssignmentDetails")

  // Relationships
  template        BadgeTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)
  userGiver       User?         @relation("UserGivenBadges", fields: [userGiverId], references: [id], onDelete: SetNull)
  guildGiver      Guild?        @relation("GuildGivenBadges", fields: [guildGiverId], references: [id], onDelete: SetNull)
  // clusterGiver    Cluster?      @relation("ClusterGivenBadges", fields: [clusterGiverId], references: [id], onDelete: SetNull) // Future
  userReceiver    User?         @relation("UserReceivedBadges", fields: [userReceiverId], references: [id], onDelete: Cascade)
  guildReceiver   Guild?        @relation("GuildReceivedBadges", fields: [guildReceiverId], references: [id], onDelete: Cascade)
  clusterReceiver Cluster?      @relation("ClusterReceivedBadges", fields: [clusterReceiverId], references: [id], onDelete: Cascade) // New

  // Links to Badge Case Items
  userBadgeItem     UserBadgeItem?
  guildBadgeItems   GuildBadgeItem[]
  clusterBadgeItems ClusterBadgeItem[] // New: links to showcases where this badge instance is displayed

  // CHECK constraint (conceptual, enforce in application logic):
  // 1. (userGiverId != null XOR guildGiverId != null XOR clusterGiverId != null) // Consider clusterGiver later
  // 2. (userReceiverId != null XOR guildReceiverId != null XOR clusterReceiverId != null)
  // 3. If guildGiverId is set, detailsOfGuildAssignmentId can be set.

  @@index([templateId])
  @@index([userGiverId])
  @@index([guildGiverId])
  @@index([userReceiverId])
  @@index([guildReceiverId])
  @@index([clusterReceiverId]) // New
}

model GuildAssignmentDetails {
  id              String        @id @default(uuid())
  badgeInstanceId String        @unique // Link back to the BadgeInstance
  badgeInstance   BadgeInstance @relation("BadgeInstanceToGuildAssignmentDetails", fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  assignmentMethod String? // e.g., "MEMBER_VOTE", "ADMIN_DECISION", "AUTOMATED_MILESTONE"
  voteRecordId     String? // If applicable, link to a vote record elsewhere
  approvalChain    Json? // Store who approved it, if a multi-step process
  notes            String? @db.Text
  assignedByUserId String? // User who actioned this guild assignment (if applicable)

  assignedByUser User? @relation("GuildAssignmentDetailsAssignedBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([badgeInstanceId])
}

model UserBadgeAllocation {
  id                String    @id @default(uuid())
  userId            String
  tier              BadgeTier // e.g., GOLD, SILVER, BRONZE
  remaining         Int       @default(0)
  lastReplenishedAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tier])
  @@index([userId])
}

model UserBadgeCase {
  id        String   @id @default(uuid())
  userId    String   @unique
  title     String?
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  badges UserBadgeItem[]
}

model UserBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String   @unique // Added @unique
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase UserBadgeCase @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge     BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model GuildBadgeCase {
  id              String   @id @default(uuid())
  guildId         String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique // Optional featured badge for special display
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  guild         Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)
  badges        GuildBadgeItem[]
  featuredBadge GuildBadgeItem?  @relation("FeaturedGuildBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model GuildBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  GuildBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance   @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn GuildBadgeCase? @relation("FeaturedGuildBadgeInCase") // Link back if this item is the featured one

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

// --- GUILD CATEGORIES ---

model Category {
  id                 String   @id @default(cuid())
  name               String   @unique
  description        String?
  isSystemCategory   Boolean  @default(false) // True if created by ViaGuild admins
  allowsGuildPrimary Boolean  @default(true) // True if users can mark a guild as 'primary' for this category
  parentId           String? // For hierarchical categories
  // creatorId           String?                 // User who created this category (if user-creatable)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  parent        Category?  @relation("SubCategories", fields: [parentId], references: [id], onDelete: SetNull)
  subcategories Category[] @relation("SubCategories")
  // creator             User?     @relation("UserCreatedCategories" fields: [creatorId], references: [id], onDelete:SetNull)

  guildsInCategories GuildCategory[] // Guilds associated with this category
  userPrimaryGuilds  UserCategoryPrimaryGuild[] // User designations of primary guilds in this category

  @@index([parentId])
}

model GuildCategory {
  guildId      String
  categoryId   String
  assignedAt   DateTime @default(now())
  assignedById String? // User ID of who assigned the guild to category (permission controlled)

  guild      Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  assignedBy User?    @relation("GuildCategoryAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@id([guildId, categoryId])
  @@index([guildId])
  @@index([categoryId])
}

model UserCategoryPrimaryGuild {
  userId     String
  categoryId String
  guildId    String // The guild the user has marked as primary for this category

  setAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  guild    Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  // User must be a member of guildId, guildId must be in categoryId, and category.allowsGuildPrimary must be true.
  @@id([userId, categoryId]) // A user can only have one primary guild per category
  @@index([userId])
  @@index([categoryId])
  @@index([guildId])
}

// --- NOTIFICATION SYSTEM ---

model Notification {
  id        String           @id @default(uuid())
  userId    String // The user who receives the notification
  type      NotificationType
  title     String
  content   String           @db.Text
  linkUrl   String? // URL to relevant page when notification is clicked
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Contextual information about the notification
  sourceId   String? // ID of related entity (guild, badge, user, etc.)
  sourceType String? // Type of source ("guild", "badgeInstance", "user", "category")
  actorId    String? // User who triggered the notification (if applicable)

  recipient User  @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  actor     User? @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, isRead])
  @@index([createdAt])
}

// Add the new GuildBan model
model GuildBan {
  id             String    @id @default(uuid())
  guildId        String // The guild that issued the ban
  bannedUserId   String // The user who was banned
  bannedByUserId String // The user who issued the ban
  reason         String?   @db.Text // Optional reason for the ban
  expiresAt      DateTime? // Null means permanent ban
  isActive       Boolean   @default(true)
  notes          String?   @db.Text // Additional context or notes
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relationships
  guild      Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  bannedUser User  @relation("BannedUser", fields: [bannedUserId], references: [id], onDelete: Cascade)
  bannedBy   User  @relation("BanIssuer", fields: [bannedByUserId], references: [id], onDelete: Restrict)

  // Indexes for efficient querying
  @@unique([guildId, bannedUserId]) // A user can only be banned once per guild
  @@index([guildId])
  @@index([bannedUserId])
  @@index([bannedByUserId])
  @@index([isActive])
  @@index([expiresAt])
}

// --- CLUSTER SYSTEM ---

model Cluster {
  id          String   @id @default(uuid())
  name        String   @unique // Unique handle/slug for the cluster
  displayName String? // For display purposes
  description String?  @db.Text
  avatar      String? // URL to image storage
  isOpen      Boolean  @default(false) // True if guilds can join without approval
  createdById String // User who created the cluster
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator User @relation("ClusterCreator", fields: [createdById], references: [id], onDelete: Restrict)

  // Relationships - Members & Structure
  guildMemberships ClusterMembership[] // Guilds that are members of this cluster
  roles            ClusterRole[]       @relation("ClusterCustomRoles") // Custom roles for this cluster
  userRoles        UserClusterRole[] // New: User roles within this cluster

  // Relationships - Primary Designation
  primaryForGuilds Guild[] @relation("PrimaryClusterForGuilds")

  // Relationships - Badges
  receivedBadgesAsCluster BadgeInstance[]   @relation("ClusterReceivedBadges") // Badges received by this cluster
  badgeCase               ClusterBadgeCase? // Cluster's showcase of received badges
  contacts                ClusterContact[] // New: Contact links for the cluster

  // Relationships - Cluster Invitations & Join Requests (as source)
  directInvitationsToGuilds ClusterDirectInvitation[] @relation("InvitingCluster")
  joinRequestsFromGuilds    ClusterJoinRequest[]      @relation("TargetClusterForJoinRequest")

  @@index([name])
}

model ClusterMembership {
  id        String   @id @default(uuid())
  guildId   String
  clusterId String
  joinedAt  DateTime @default(now())

  guild   Guild   @relation(fields: [guildId], references: [id], onDelete: Cascade)
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([guildId, clusterId])
  @@index([guildId])
  @@index([clusterId])
}

model ClusterRole {
  id           String   @id @default(cuid())
  name         String
  description  String?
  clusterId    String? // Link to the specific cluster, optional for system roles
  isSystemRole Boolean  @default(false) // e.g., CLUSTER_OWNER, CLUSTER_ADMIN
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  cluster          Cluster?                @relation("ClusterCustomRoles", fields: [clusterId], references: [id], onDelete: Cascade) // Made Cluster optional
  permissions      ClusterRolePermission[] // Link to the permissions this cluster role has
  userClusterRoles UserClusterRole[]

  @@unique([name, clusterId])
  @@index([clusterId])
}

model UserClusterRole {
  id            String   @id @default(cuid())
  userId        String
  clusterId     String // To identify the cluster context directly
  clusterRoleId String
  assignedAt    DateTime @default(now())
  // assignedById String? // User who assigned this cluster role

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cluster     Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade) // Direct link to Cluster
  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("UserClusterRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, clusterId, clusterRoleId], name: "uniqueUserClusterRoleInCluster")
  @@index([userId])
  @@index([clusterId])
  @@index([clusterRoleId])
}

model ClusterBadgeCase {
  id              String   @id @default(uuid())
  clusterId       String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cluster       Cluster            @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  badges        ClusterBadgeItem[]
  featuredBadge ClusterBadgeItem?  @relation("FeaturedClusterBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model ClusterBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  ClusterBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance     @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn ClusterBadgeCase? @relation("FeaturedClusterBadgeInCase")

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

// New model for Cluster Contacts
model ClusterContact {
  id           String      @id @default(uuid())
  clusterId    String
  type         ContactType // Reusing the existing ContactType enum
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, displayOrder])
}

// New model for linking ClusterRoles to Permissions
model ClusterRolePermission {
  id            String   @id @default(cuid())
  clusterRoleId String
  permissionId  String
  assignedAt    DateTime @default(now())
  // assignedById  String?  // Optional: User who assigned this permission to the cluster role (for auditing)

  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  permission  Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("ClusterRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([clusterRoleId, permissionId])
  @@index([clusterRoleId])
  @@index([permissionId])
}

// --- GUILD INVITATION SYSTEM ---

model GuildDirectInvitation {
  id               String                @id @default(uuid())
  guildId          String
  invitedByUserId  String // User who sent the invitation
  targetUserId     String? // User who received the invitation (if they exist in ViaGuild system)
  targetUserHandle String // The handle/username used for the invitation (e.g. "username123", "user@example.com")
  platform         InvitationPlatform // Platform of the targetUserHandle (e.g. VIAGUILD, TWITTER, DISCORD)
  status           GuildInvitationStatus @default(PENDING)
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  expiresAt        DateTime? // Optional: For invitations that have a time limit

  guild         Guild @relation("InvitedToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  invitedByUser User  @relation("Inviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser    User? @relation("InvitedUser", fields: [targetUserId], references: [id], onDelete: SetNull) // Null if invited user is not yet on platform

  @@unique([guildId, targetUserHandle, platform], name: "uniqueInvitationByHandle") // Prevent duplicate invites to the same handle for the same guild
  @@index([guildId])
  @@index([invitedByUserId])
  @@index([targetUserId])
  @@index([targetUserHandle, platform])
  @@index([status])
}

model GuildInvitationLink {
  id              String    @id @default(uuid()) // Can also be a unique string code if preferred over UUID
  guildId         String
  createdByUserId String
  code            String    @unique // The unique, shareable code for the link
  maxUses         Int? // Null for unlimited uses
  currentUses     Int       @default(0)
  expiresAt       DateTime? // Null for no expiration
  revokedAt       DateTime? // Timestamp if the link was manually revoked
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  guild         Guild @relation("LinkForGuild", fields: [guildId], references: [id], onDelete: Cascade)
  createdByUser User  @relation("LinkCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([createdByUserId])
  @@index([code])
}

model GuildJoinRequest {
  id               String                 @id @default(uuid())
  guildId          String
  userId           String // User requesting to join
  message          String?                @db.Text // Optional message from the user
  status           GuildJoinRequestStatus @default(PENDING)
  reviewedByUserId String? // Admin/Owner who reviewed the request
  reviewedAt       DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  guild          Guild @relation("RequestToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  requestingUser User  @relation("Requester", fields: [userId], references: [id], onDelete: Cascade)
  reviewedByUser User? @relation("Reviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([guildId, userId]) // User can only have one pending request per guild
  @@index([guildId])
  @@index([userId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- CLUSTER INVITATION & JOIN REQUEST SYSTEM ---

model ClusterDirectInvitation {
  id              String                        @id @default(uuid())
  clusterId       String // The cluster sending the invitation
  invitedByUserId String // User (cluster admin) who sent the invitation
  targetGuildId   String // The guild being invited
  status          ClusterDirectInvitationStatus @default(PENDING)
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime? // Optional: for invitations that have a time limit

  invitingCluster Cluster @relation("InvitingCluster", fields: [clusterId], references: [id], onDelete: Cascade)
  invitedByUser   User    @relation("ClusterInviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetGuild     Guild   @relation("TargetGuildForClusterInvitation", fields: [targetGuildId], references: [id], onDelete: Cascade)

  @@unique([clusterId, targetGuildId], name: "uniqueClusterToGuildInvitation")
  @@index([clusterId])
  @@index([invitedByUserId])
  @@index([targetGuildId])
  @@index([status])
}

model ClusterJoinRequest {
  id                String                   @id @default(uuid())
  clusterId         String // The cluster being requested to join
  requestingGuildId String // The guild making the request
  requestedByUserId String // User from the requesting guild who initiated the request
  message           String?                  @db.Text
  status            ClusterJoinRequestStatus @default(PENDING)
  reviewedByUserId  String? // User (cluster admin) who reviewed the request
  reviewedAt        DateTime?
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt

  targetCluster   Cluster @relation("TargetClusterForJoinRequest", fields: [clusterId], references: [id], onDelete: Cascade)
  requestingGuild Guild   @relation("RequestingGuildForClusterJoin", fields: [requestingGuildId], references: [id], onDelete: Cascade)
  requestedByUser User    @relation("ClusterJoinRequester", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  reviewedByUser  User?   @relation("ClusterJoinRequestReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([clusterId, requestingGuildId], name: "uniqueGuildToClusterJoinRequest")
  @@index([clusterId])
  @@index([requestingGuildId])
  @@index([requestedByUserId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- GUILD RELATIONSHIP PROPOSAL SYSTEM ---

model GuildRelationshipProposal {
  id                   String                     @id @default(uuid())
  proposingGuildId     String
  targetGuildId        String
  proposedType         RelationshipType
  status               RelationshipProposalStatus @default(PENDING)
  messageFromProposer  String?                    @db.Text
  messageFromResponder String?                    @db.Text
  proposedByUserId     String
  resolvedByUserId     String?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  expiresAt            DateTime?

  proposingGuild Guild @relation("ProposingGuildForRelationship", fields: [proposingGuildId], references: [id], onDelete: Cascade)
  targetGuild    Guild @relation("TargetGuildForRelationship", fields: [targetGuildId], references: [id], onDelete: Cascade)
  proposedByUser User  @relation("ProposedByUser", fields: [proposedByUserId], references: [id], onDelete: Cascade) // Relation name to match User model
  resolvedByUser User? @relation("ResolvedByUser", fields: [resolvedByUserId], references: [id], onDelete: SetNull) // Relation name to match User model

  @@unique([proposingGuildId, targetGuildId, proposedType, status], name: "unique_pending_guild_relationship_proposal") // Prevents identical pending proposals
  @@index([proposingGuildId])
  @@index([targetGuildId])
  @@index([status])
  @@index([proposedByUserId])
  @@index([resolvedByUserId])
}
