// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum GuildMemberRank {
  S
  A
  B
  C
  D
  E // Default rank
}

enum RelationshipType {
  PARENT // Defines a hierarchical relationship where sourceGuildId is parent, targetGuildId is child
  PARTNER
  RIVAL
  // WAR // Example for future unilateral type
}

enum ContactType {
  WEBSITE
  EMAIL
  DISCORD
  TWITTER
  BLUESKY
  TWITCH
  GITHUB
  LINKEDIN
  CUSTOM
}

enum BadgeShape {
  CIRCLE
  STAR
  HEART
  HEXAGON
  SQUARE // Added
}

enum BadgeTier {
  GOLD
  SILVER
  BRONZE
}

// --- Configuration Enums (for validating badge display properties) ---


// Optional: Describes a predefined visual style for text elements.
// enum TextStyle {
//   METADATA_DEFAULT
//   METADATA_HIGHLIGHT
//   FOREGROUND_TITLE
// }
// --- END Configuration Enums ---

enum EntityType {
  USER
  GUILD
  CLUSTER
}

enum NotificationType {
  GUILD_INVITE
  BADGE_RECEIVED
  GUILD_JOIN_REQUEST
  RELATIONSHIP_REQUEST // This might be deprecated or reused for general relationship updates
  GUILD_UPDATE
  NEW_GUILD_MEMBER
  ROLE_ASSIGNED
  RANK_UPDATED
  CATEGORY_PRIMARY_SET

  // Guild Relationship Proposal Notifications
  GUILD_RELATIONSHIP_PROPOSAL_RECEIVED
  GUILD_RELATIONSHIP_PROPOSAL_ACCEPTED
  GUILD_RELATIONSHIP_PROPOSAL_REJECTED
  GUILD_RELATIONSHIP_PROPOSAL_REVOKED
  GUILD_RELATIONSHIP_PROPOSAL_EXPIRED
  // Add more as new features arise
}

enum AssetStatus {
  UPLOADING   // Asset is being uploaded
  PROCESSING  // Asset is being processed (e.g., extracting metadata)
  TEMP        // Temporary asset with expiration
  PERMANENT   // Permanently stored asset
  DELETED     // Asset has been deleted from storage
}

// --- Guild Invitation System Enums ---
enum GuildInvitationStatus {
  PENDING // Invitation sent, awaiting response
  ACCEPTED // Invitation accepted, user is now a member or will be processed as one
  REJECTED // Invitation explicitly rejected by the target
  EXPIRED // Invitation expired due to time limit (if applicable)
  REVOKED // Invitation withdrawn by guild admin/owner
  CONSUMED // Invitation automatically processed (e.g., due to new social link or joining via another means)
}

enum InvitationPlatform {
  VIAGUILD // ViaGuild username
  TWITTER
  BLUESKY
  TWITCH
  DISCORD
  // EMAIL // Potentially for future use
  // OTHER // Generic for unlisted platforms
}

enum GuildJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- Cluster Invitation/Join Request System Enums ---
enum ClusterDirectInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED
  EXPIRED // Optional: if cluster-to-guild invites can expire
}

enum RelationshipProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED // By the proposer
  EXPIRED
  SUPERSEDED // When another proposal between the same guilds is accepted
}

enum ClusterJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- NEW ENUM for Badge Instance Acceptance Status ---
enum BadgeAwardStatus {
  PENDING_ACCEPTANCE // Newly awarded, receiver hasn't acknowledged/accepted
  ACCEPTED // Receiver has accepted the badge into their collection
  REJECTED // Receiver has explicitly rejected the badge
}

// --- CORE MODELS ---

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  email_ci       String   @unique // Case-insensitive version for uniqueness and lookup
  username       String   @unique // Unique handle
  username_ci    String   @unique // Case-insensitive version for uniqueness and lookup
  displayName    String? // For display purposes
  passwordHash   String
  bio            String?
  avatar         String? // Current: Base64/file path. Future: hostedUrl from UploadedAsset
  isPublic       Boolean  @default(true)
  hiddenAccounts String[] @default([]) // Array of social account IDs to hide
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships - Social & Guilds
  socialAccounts   SocialAccount[]
  createdGuilds    Guild[]           @relation("GuildCreator")
  updatedGuilds    Guild[]           @relation("GuildUpdater") // Guilds last updated by this user
  guildMemberships GuildMembership[]
  // createdRelationships GuildRelationship[] @relation("RelationshipCreator") // Guild relationships created by this user // REMOVED

  // Guild Relationships - as proposer or accepter
  proposedGuildRelationships GuildRelationship[] @relation("RelationshipProposer")
  acceptedGuildRelationships GuildRelationship[] @relation("RelationshipAccepter")

  // Guild Relationship Proposals - as initiator or resolver
  initiatedGuildRelationshipProposals GuildRelationshipProposal[] @relation("ProposedByUser")
  resolvedGuildRelationshipProposals  GuildRelationshipProposal[] @relation("ResolvedByUser")

  // --- BADGE SYSTEM RELATIONS (Updated) ---
  authoredBadgeTemplates BadgeTemplate[]       @relation("AuthoredByRelation") // Templates authored by this user
  badgeAllocations       UserBadgeAllocation[] // Tiered badge allocations for this user
  badgeCase              UserBadgeCase?
  uploadedAssets         UploadedAsset[]       @relation("UserUploadedAssets")
  // --- END BADGE SYSTEM RELATIONS ---

  // Relationships - Categories
  primaryGuildsPerCategory UserCategoryPrimaryGuild[] // User's designated primary guilds for specific categories
  // createdCategories         Category[]              @relation("UserCreatedCategories") // If users can create categories

  // Relationships - Notifications
  notifications      Notification[] @relation("NotificationRecipient")
  actorNotifications Notification[] @relation("NotificationActor") // Notifications where this user was the actor

  // Add these relations
  bansReceived GuildBan[] @relation("BannedUser")
  bansIssued   GuildBan[] @relation("BanIssuer")

  // Relations for audit trails (who assigned what)
  guildRolePermissionsAssignedBy    GuildRolePermission[]        @relation("GuildRolePermissionAssignedBy")
  platformRoleAssignments           UserPlatformRoleAssignment[] @relation("UserPlatformAssignments")
  platformRolePermissionsAssignedBy PlatformRolePermission[]     @relation("PlatformRolePermissionAssignedBy")
  guildRoleSettingsAssignedBy       GuildRoleSetting[]           @relation("GuildRoleSettingAssignedBy")
  clusterRoleSettingsAssignedBy     ClusterRoleSetting[]         @relation("ClusterRoleSettingAssignedBy")
  clusterRolePermissionsAssignedBy  ClusterRolePermission[]      @relation("ClusterRolePermissionAssignedBy")
  guildBadgeAssignmentsActioned     GuildAssignmentDetails[]     @relation("GuildAssignmentDetailsAssignedBy")
  guildCategoriesAssignedBy         GuildCategory[]              @relation("GuildCategoryAssignedBy")

  createdClusters Cluster[]         @relation("ClusterCreator")
  clusterRoles    UserClusterRole[] // Roles held by the user in various clusters

  // Relationships - Guild Invitations & Join Requests
  sentGuildDirectInvitations     GuildDirectInvitation[] @relation("Inviter")
  receivedGuildDirectInvitations GuildDirectInvitation[] @relation("InvitedUser")
  createdGuildInvitationLinks    GuildInvitationLink[]   @relation("LinkCreator")
  guildJoinRequests              GuildJoinRequest[]      @relation("Requester")
  reviewedGuildJoinRequests      GuildJoinRequest[]      @relation("Reviewer")

  // Relationships - Cluster Invitations & Join Requests (as initiator/reviewer)
  sentClusterDirectInvitations ClusterDirectInvitation[] @relation("ClusterInviter")
  initiatedClusterJoinRequests ClusterJoinRequest[]      @relation("ClusterJoinRequester")
  reviewedClusterJoinRequests  ClusterJoinRequest[]      @relation("ClusterJoinRequestReviewer")

  platformRolesAssignedByUser UserPlatformRoleAssignment[] @relation("PlatformRoleAssignedBy")
}

model SocialAccount {
  id                   String   @id @default(uuid())
  provider             String // "twitter", "bluesky", "twitch", "discord"
  providerId           String // ID from the provider
  username             String // Username from the provider
  username_ci          String? // Case-insensitive version for searching. Nullable to match original if username can be null. Assuming username is not nullable based on usage.
  encryptedCredentials String? // Encrypted app password or OAuth token for future use (e.g. posting on their behalf)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
  @@index([username_ci]) // Index for case-insensitive searches
}

model Guild {
  id                String   @id @default(uuid())
  name              String   @unique // Unique handle/slug for the guild
  name_ci           String   @unique // Case-insensitive version for uniqueness
  displayName       String? // For display purposes
  description       String   @db.Text
  avatar            String? // Current: URL to image storage. Future: hostedUrl from UploadedAsset
  isOpen            Boolean  @default(false) // If true, users can join automatically without needing permission/invitation.
  allowJoinRequests Boolean  @default(true) // If true, users can submit requests to join this guild (moderated).
  createdById       String
  updatedById       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationships - Creator/Updater
  creator   User  @relation("GuildCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy User? @relation("GuildUpdater", fields: [updatedById], references: [id], onDelete: SetNull)

  // Relationships - Members & Structure
  memberships  GuildMembership[]
  customRoles  GuildRole[]        @relation("GuildCustomRoles") // MODIFIED relation name if GuildRole references Guild
  contacts     GuildContact[]
  roleSettings GuildRoleSetting[]

  // --- BADGE SYSTEM RELATIONS (Updated) ---
  badgeCase             GuildBadgeCase? // Guild's showcase of received badges
  // --- END BADGE SYSTEM RELATIONS ---

  // Relationships - Inter-Guild
  outgoingRelationships GuildRelationship[] @relation("SourceRelationships")
  incomingRelationships GuildRelationship[] @relation("TargetRelationships")

  // Relationships - Inter-Guild Proposals
  sentRelationshipProposals     GuildRelationshipProposal[] @relation("ProposingGuildForRelationship")
  receivedRelationshipProposals GuildRelationshipProposal[] @relation("TargetGuildForRelationship")

  // Relationships - Categories
  categories                    GuildCategory[] // Categories this guild belongs to
  designatedAsPrimaryInCategory UserCategoryPrimaryGuild[] // Instances where this guild is marked primary for a category by users

  // Relationships - Clusters
  primaryClusterId   String?             @unique // Optional: A guild can have one primary cluster
  primaryCluster     Cluster?            @relation("PrimaryClusterForGuilds", fields: [primaryClusterId], references: [id], onDelete: SetNull)
  clusterMemberships ClusterMembership[] // Guilds that are members of this cluster

  // Add this relation
  bans GuildBan[]

  // Relationships - Guild Invitations & Join Requests
  directInvitations GuildDirectInvitation[] @relation("InvitedToGuild")
  invitationLinks   GuildInvitationLink[]   @relation("LinkForGuild")
  joinRequests      GuildJoinRequest[]      @relation("RequestToGuild")

  // Relationships - Cluster System (as target of invite or requester of join)
  receivedClusterDirectInvitations ClusterDirectInvitation[] @relation("TargetGuildForClusterInvitation")
  sentClusterJoinRequests          ClusterJoinRequest[]      @relation("RequestingGuildForClusterJoin")

  @@index([name])
  @@index([primaryClusterId])
}

// --- PERMISSION SYSTEM ---
model Permission {
  id              String   @id @default(cuid())
  key             String   @unique // e.g., "GUILD_KICK_MEMBER", "BADGE_TEMPLATE_CREATE_GUILD"
  description     String?
  permissionGroup String? // For UI grouping, e.g., "Guild Management", "Badge Administration"
  createdAt       DateTime @default(now())

  platformRolePermissions PlatformRolePermission[]
  guildRolePermissions    GuildRolePermission[]
  clusterRolePermissions  ClusterRolePermission[]

  @@index([key])
}

// --- Platform Roles (NEW) ---
model PlatformRole {
  id              String  @id @default(cuid())
  name            String  @unique
  name_ci         String  @unique
  description     String?
  isSystemDefined Boolean @default(true)

  permissions     PlatformRolePermission[]
  userAssignments UserPlatformRoleAssignment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("PlatformRole")
}

model UserPlatformRoleAssignment {
  id             String   @id @default(cuid())
  userId         String
  platformRoleId String
  assignedAt     DateTime @default(now())
  assignedById   String?

  user         User         @relation("UserPlatformAssignments", fields: [userId], references: [id], onDelete: Cascade)
  platformRole PlatformRole @relation(fields: [platformRoleId], references: [id], onDelete: Cascade)
  assignedBy   User?        @relation("PlatformRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, platformRoleId])
  @@map("UserPlatformRoleAssignment")
}

model PlatformRolePermission {
  id             String   @id @default(cuid())
  platformRoleId String
  permissionId   String
  assignedAt     DateTime @default(now())
  assignedById   String?

  platformRole PlatformRole @relation(fields: [platformRoleId], references: [id], onDelete: Cascade)
  permission   Permission   @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy   User?        @relation("PlatformRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([platformRoleId, permissionId])
  @@index([platformRoleId])
  @@index([permissionId])
  @@map("PlatformRolePermission")
}

// --- Guild Roles (Formerly Role) ---
model GuildRole {
  id            String  @id @default(cuid())
  name          String
  name_ci       String
  description   String?
  guildId       String? // NULL for system role templates (MEMBER, MODERATOR, ADMIN, FOUNDER), NOT NULL for custom guild roles
  isSystemRole  Boolean @default(false) // True for templates like MEMBER, FOUNDER, ADMIN, MODERATOR
  isDefaultRole Boolean @default(false) // True for MEMBER template typically

  displayColor String? @default("#07AABC") @map("display_color")
  apiVisible   Boolean @default(false) @map("api_visible")

  permissions            GuildRolePermission[] // Permissions this guild role (or template) has
  assignedToGuildMembers UserGuildRole[] // Instances of this role being assigned
  guildSettings          GuildRoleSetting[] // Guild-specific settings for this role template or custom role

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // For custom roles, this links to the guild it belongs to. Null for system templates.
  guild Guild? @relation("GuildCustomRoles", fields: [guildId], references: [id], onDelete: Cascade)
  // For system templates (guildId is NULL), name_ci should be globally unique.
  // This requires either a partial index (manual SQL) or application-level enforcement / careful seeding.
  // Or, if all name_ci must be globally unique regardless of guildId, then name_ci @unique.
  // For now, relying on seeding for system template name_ci uniqueness.

  @@unique([guildId, name_ci], name: "unique_custom_guild_role_name_ci")
  @@index([guildId])
  @@index([apiVisible])
  @@map("GuildRole")
}

model GuildRolePermission {
  id           String   @id @default(cuid())
  guildRoleId  String // RENAMED from roleId
  permissionId String
  assignedAt   DateTime @default(now())
  assignedById String? // for auditing

  guildRole  GuildRole  @relation(fields: [guildRoleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy User?      @relation("GuildRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([guildRoleId, permissionId]) // RENAMED
  @@index([guildRoleId]) // ADDED
  @@index([permissionId]) // ADDED
  @@map("GuildRolePermission")
}

// UserSystemRole IS DELETED / REPLACED by UserPlatformRoleAssignment

// --- GUILD STRUCTURE & MEMBERSHIP ---
model GuildMembership {
  id           String          @id @default(uuid())
  userId       String
  guildId      String
  isPrimary    Boolean         @default(false) // Global primary guild for the user
  primarySetAt DateTime? // When this guild was set as primary
  rank         GuildMemberRank @default(E)
  joinedAt     DateTime        @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  assignedRoles UserGuildRole[]

  @@unique([userId, guildId], name: "uniqueUserGuildMembership")
  @@index([userId])
  @@index([guildId])
  @@index([userId, isPrimary])
}

// NEW JOIN TABLE: UserGuildRole
model UserGuildRole {
  id                String   @id @default(cuid())
  guildMembershipId String
  guildRoleId       String // RENAMED from roleId
  assignedAt        DateTime @default(now())
  // assignedByUserId String? // Optional: User who assigned this specific role to the member

  guildMembership GuildMembership @relation(fields: [guildMembershipId], references: [id], onDelete: Cascade)
  guildRole       GuildRole       @relation(fields: [guildRoleId], references: [id], onDelete: Restrict) // RENAMED

  // assignedBy   User?        @relation("RoleAssignedToMemberBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)
  @@unique([guildMembershipId, guildRoleId]) // A member can't have the same specific role within a guild more than once
  @@index([guildMembershipId])
  @@index([guildRoleId]) // RENAMED
  @@map("UserGuildRole")
}

model GuildRoleSetting {
  id          String @id @default(cuid())
  guildId     String
  guildRoleId String // RENAMED from roleId

  hierarchyOrder       Int
  displaySequence      Int?
  overrideRoleName     String?
  overrideDisplayColor String?
  isFeatured           Boolean @default(false)

  assignedById String? // Optional: who configured this setting

  guild      Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  role       GuildRole @relation(fields: [guildRoleId], references: [id], onDelete: Cascade) // RENAMED relation and type
  assignedBy User?     @relation("GuildRoleSettingAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([guildId, guildRoleId]) // RENAMED roleId      
  @@index([guildId, hierarchyOrder])
  @@index([guildId, displaySequence])
  @@index([guildRoleId]) // RENAMED roleId
  @@map("GuildRoleSetting")
}

model GuildRelationship {
  id             String           @id @default(uuid())
  sourceGuildId  String
  targetGuildId  String
  type           RelationshipType
  // createdById   String // User who created the relationship
  proposerUserId String? // User who initiated the proposal or unilateral action
  accepterUserId String? // User who accepted a proposal; nullable for unilateral actions
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  sourceGuild  Guild @relation("SourceRelationships", fields: [sourceGuildId], references: [id], onDelete: Cascade)
  targetGuild  Guild @relation("TargetRelationships", fields: [targetGuildId], references: [id], onDelete: Cascade)
  // creator     User  @relation("RelationshipCreator", fields: [createdById], references: [id], onDelete: Restrict) // REMOVED
  proposerUser User? @relation("RelationshipProposer", fields: [proposerUserId], references: [id], onDelete: SetNull)
  accepterUser User? @relation("RelationshipAccepter", fields: [accepterUserId], references: [id], onDelete: SetNull)

  @@unique([sourceGuildId, targetGuildId])
  @@index([sourceGuildId])
  @@index([targetGuildId])
}

model GuildContact {
  id           String      @id @default(uuid())
  guildId      String
  type         ContactType
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, displayOrder])
}

// --- BADGE SYSTEM (REVISED with Tables Solution) ---

model BadgeTemplate {
  id              String  @id @default(uuid())
  templateSlug    String // NEW: Immutable, machine-friendly unique key for this template type, scoped by owner.
  templateSlug_ci String // Case-insensitive version
  internalNotes   String? @db.Text // Internal notes about template purpose

  // Ownership and Creation (of the template)
  authoredByUserId String?
  authoredByUser   User?   @relation("AuthoredByRelation", fields: [authoredByUserId], references: [id], onDelete: SetNull)
  
  // Discriminated union fields for ownership
  ownerType EntityType?
  ownerId   String?

  // Lifecycle & Behavior
  isArchived                  Boolean @default(false) // Whether the template owner has archived/soft-deleted this template (it is not deleted from the db if there exist awarded badge instances with this template)
  isModifiableByIssuer        Boolean @default(false) // Can this template be modified? (changes propagate to non-overridden properties of awarded badges)
  allowsPushedInstanceUpdates Boolean @default(false) // Can the issuer modify individual instances of this badge post-award?

  // --- Tier Configuration ---
  inherentTier BadgeTier? // Renamed from defaultTier. Optional: The inherent tier of this template, influences allocation use & can enforce/suggest styling (e.g., border color).

  // --- Default Display Properties (Effectively the "Display Config" embedded) ---
  defaultBadgeName          String // Default display name
  defaultSubtitleText       String? // Default subtitle text
  defaultOuterShape         BadgeShape            @default(CIRCLE)
  
  // --- Unified Visual Configuration (NEW) ---
  // These JSON config objects provide flexible styling while maintaining queryable type/value fields above.
  // They serve as the "source of truth" for rich styling, while type/value fields enable fast queries.
  
  defaultBorderConfig       Json? // Border styling configuration object
  // Structure: { type: "simple-color", version: 1, color: "#RRGGBB" | "#RRGGBBAA" }
  // Future: { type: "gradient", version: 1, colors: [...], direction?: string }
  // Future: { type: "pattern", version: 1, patternUrl: string, color: string }
  
  defaultBackgroundConfig   Json? // Background styling configuration object - will replace defaultBackgroundType/Value fields
  // Structure for solid colors: { type: "simple-color", version: 1, color: "#RRGGBB" | "#RRGGBBAA" }
  // Structure for uploaded images: { type: "static-image-asset", version: 1, url: "upload://asset-id", scale?: number }
  // Note: type field replaces defaultBackgroundType enum, url/color replaces defaultBackgroundValue
  // Future: { type: "gradient", version: 1, colors: [...], direction?: string }
  // Future: { type: "pattern", version: 1, patternUrl: string, opacity?: number }
  
  defaultForegroundConfig   Json? // Foreground styling configuration object - will replace defaultForegroundType/Value fields
  // Structure for simple colors: { type: "simple-color", version: 1, color: "#RRGGBB" | "#RRGGBBAA" }
  // Structure for text: { type: "text", version: 1, value: string, color: "#RRGGBB", font?: string, size?: number, scale?: number }
  // Structure for system icons: { type: "system-icon", version: 1, value: string, color?: "#RRGGBB", scale?: number }
  // Structure for uploaded images: { type: "static-image-asset", version: 1, url: "upload://asset-id", scale?: number }
  // Structure for customizable SVGs: { 
  //   type: "customizable-svg", 
  //   version: 1,
  //   url: "upload://asset-id",
  //   scale?: number,
  //   colorMappings: {
  //     "[element-path-selector]": { 
  //       fill?: { original: string, current: string }, 
  //       stroke?: { original: string, current: string } 
  //     }
  //   }
  // }
  // Example: {
  //   type: "customizable-svg", version: 1, url: "upload://asset-id", scale: 0.8,
  //   colorMappings: {
  //     "g[0]/path[0]": { fill: { original: "#ff0000", current: "#00ff00" }, stroke: { original: "UNSPECIFIED", current: "#000000" } },
  //     "g[0]/circle[0]": { fill: { original: "UNSPECIFIED", current: "#ffffff" } }
  //   }
  // }
  // Note: type field replaces defaultForegroundType enum, value/url replaces defaultForegroundValue, font/size replace defaultTextFont/Size
  // Future: { type: "gradient", version: 1, colors: [...], direction?: string }
  // Future: { type: "shadow", version: 1, color: string, offsetX: number, offsetY: number, blur: number }
  
  defaultDisplayDescription String?               @db.Text // Default user-facing description for this badge type

  // --- Programmatic Credential Configuration ---
  definesMeasure        Boolean @default(false) // Does this template type utilize BadgeInstance.measureValue?
  measureLabel          String? // How to label this metric if shown, e.g., "Rank", "Security Level"
  measureBest           Float? // Numeric value representing the best possible score/rank
  measureWorst          Float? // Numeric value representing the worst possible score/rank
  measureNotes          String? // e.g. the measureValue represents xyz and is calculated in such and such way
  measureIsNormalizable Boolean @default(false) // Hints if the measureValue can be normalized from 0 to 1
  higherIsBetter        Boolean? // If true, a greater measureValue is considered better; if false, a lesser value is better. Null if definesMeasure is false.
  measureBestLabel      String? // e.g., "Max Score", "Top Rank"
  measureWorstLabel     String? // e.g., "Min Score", "Lowest Rank"
  
  metadataFieldDefinitions MetadataFieldDefinition[] // Defines slots for displayable textual metadata
  instances                BadgeInstance[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Note: For system templates (ownedByUserId=null, ownedByGuildId=null), 
  // uniqueness of templateSlug needs to be ensured by application/seeding logic (e.g. prefixing with "system_")
  // or by making templateSlug globally @unique if preferred (but then requires globally unique names from users/guilds too).
  // The current setup with scoped uniques is generally more flexible for user/guild created templates.

  // Note: We can't create unique constraints on nullable discriminated union fields
  // Application logic must enforce uniqueness of templateSlug per owner
  @@index([authoredByUserId])
  @@index([ownerType, ownerId])
  @@index([isArchived])
  @@index([isModifiableByIssuer])
  @@index([allowsPushedInstanceUpdates])
  @@index([inherentTier])
}

// Defines a slot for DISPLAYABLE instance-specific textual metadata
model MetadataFieldDefinition {
  id              String        @id @default(uuid())
  badgeTemplateId String // Foreign key to BadgeTemplate
  badgeTemplate   BadgeTemplate @relation(fields: [badgeTemplateId], references: [id], onDelete: Cascade)

  fieldKeyForInstanceData String // The key used in `InstanceMetadataValue.dataKey`
  label                   String // e.g., "Date Achieved:", "Score:"
  prefix                  String?
  suffix                  String?
  style                   String? // e.g., "METADATA_DEFAULT", maps to CSS/UI styling
  displayOrder            Int     @default(0)

  @@unique([badgeTemplateId, fieldKeyForInstanceData])
  @@index([badgeTemplateId, displayOrder])
}

model BadgeInstance {
  id         String        @id @default(uuid())
  templateId String
  template   BadgeTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  // --- Giver (Discriminated Union) ---
  giverType EntityType
  giverId   String

  // --- Receiver (Discriminated Union) ---
  receiverType EntityType
  receiverId   String

  assignedAt DateTime  @default(now())
  revokedAt  DateTime?
  message    String?   @db.Text

  // --- Direct, Typed Fields for Core Visual Overrides (Nullable) ---
  overrideBadgeName          String?
  overrideSubtitle           String?
  overrideOuterShape         BadgeShape?
  
  // --- Unified Visual Configuration Overrides (NEW) ---
  // These JSON config objects override the template's default styling for this specific badge instance.
  // They follow the same structure as the template default configs above.
  
  overrideBorderConfig       Json? // Border styling overrides - same structure as defaultBorderConfig
  overrideBackgroundConfig   Json? // Background styling overrides - same structure as defaultBackgroundConfig  
  overrideForegroundConfig   Json? // Foreground styling overrides - same structure as defaultForegroundConfig
  // See defaultBorderConfig, defaultBackgroundConfig, and defaultForegroundConfig above for complete structure documentation
  
  overrideDisplayDescription String?                @db.Text

  // Overrides for measure properties from the template
  overrideMeasureBest           Float? 
  overrideMeasureWorst          Float? 
  overrideMeasureIsNormalizable Boolean? 
  overrideMeasureBestLabel      String?
  overrideMeasureWorstLabel     String?

  // --- Dedicated Field for Programmatic measure Value ---
  measureValue Float? // This value is the metric used for programmatic checks.

  // --- Instance Status & API Visibility ---
  awardStatus BadgeAwardStatus @default(PENDING_ACCEPTANCE) // Status of the badge award itself
  apiVisible  Boolean          @default(false) // Receiver-controlled: if true, this badge is visible to API/programmatic checks. Set to true upon acceptance, can be toggled by receiver.

  // --- Link to Instance-Specific DISPLAYABLE METADATA Values ---
  metadataValues InstanceMetadataValue[] // Stores values for fields defined in MetadataFieldDefinition

  guildAssignmentDetails GuildAssignmentDetails? @relation("BadgeInstanceToGuildAssignmentDetails")

  // Links to Badge Case Items
  userBadgeItem     UserBadgeItem? // Link to badgecase where this badge instance is displayed
  guildBadgeItems   GuildBadgeItem[] // Link to badgecases where this badge instance is displayed
  clusterBadgeItems ClusterBadgeItem[] // Link to badgecases where this badge instance is displayed

  // CHECK constraint (conceptual, enforce in application logic):
  // 1. giverType and giverId must form a valid reference (e.g., if giverType = 'USER', giverId must be a valid user ID)
  // 2. receiverType and receiverId must form a valid reference (e.g., if receiverType = 'GUILD', receiverId must be a valid guild ID)
  // 3. If giverType is 'GUILD', detailsOfGuildAssignmentId can be set.
  //    (The link is via GuildAssignmentDetails.badgeInstanceId pointing to this BadgeInstance.id)

  @@index([templateId])
  @@index([giverType, giverId])
  @@index([receiverType, receiverId])
  @@index([measureValue])
  @@index([awardStatus])
  @@index([apiVisible])
}

// Stores the actual key-value pairs for DISPLAYABLE textual metadata for a specific BadgeInstance
model InstanceMetadataValue {
  id              String        @id @default(uuid())
  badgeInstanceId String
  badgeInstance   BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  // This `dataKey` MUST match a `fieldKeyForInstanceData` from one of the
  // BadgeInstance's template's associated MetadataFieldDefinitions.
  dataKey   String // e.g., "dateAchieved", "playerScore", "reasonForAward"
  dataValue String // Actual metadata value (application logic parses if needed)

  @@unique([badgeInstanceId, dataKey])
  @@index([badgeInstanceId])
}

model GuildAssignmentDetails {
  id               String        @id @default(uuid())
  badgeInstanceId  String        @unique
  badgeInstance    BadgeInstance @relation("BadgeInstanceToGuildAssignmentDetails", fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  assignmentMethod String?
  voteRecordId     String?
  approvalChain    Json?
  notes            String?       @db.Text
  assignedByUserId String?
  assignedByUser   User?         @relation("GuildAssignmentDetailsAssignedBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([badgeInstanceId])
}

model UserBadgeAllocation {
  id                String    @id @default(uuid())
  userId            String
  tier              BadgeTier
  remaining         Int       @default(0)
  lastReplenishedAt DateTime  @default(now())
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tier])
  @@index([userId])
}

model UserBadgeCase {
  id        String          @id @default(uuid())
  userId    String          @unique
  title     String?
  isPublic  Boolean         @default(true)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  badges    UserBadgeItem[]
}

model UserBadgeItem {
  id              String        @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String        @unique
  displayOrder    Int           @default(0)
  addedAt         DateTime      @default(now())
  badgeCase       UserBadgeCase @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge           BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model GuildBadgeCase {
  id              String           @id @default(uuid())
  guildId         String           @unique
  title           String?
  isPublic        Boolean          @default(true)
  featuredBadgeId String?          @unique // Optional featured badge for special display
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  guild           Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)
  badges          GuildBadgeItem[]
  featuredBadge   GuildBadgeItem?  @relation("FeaturedGuildBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model GuildBadgeItem {
  id              String          @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int             @default(0)
  addedAt         DateTime        @default(now())
  badgeCase       GuildBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge           BadgeInstance   @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn      GuildBadgeCase? @relation("FeaturedGuildBadgeInCase")

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model UploadedAsset {
  id                 String       @id @default(cuid())
  uploaderId         String?   
  uploader           User?        @relation("UserUploadedAssets", fields: [uploaderId], references: [id], onDelete: SetNull)
  originalFilename   String?
  mimeType           String    
  sizeBytes          Int       
  hostedUrl          String       @unique
  storageIdentifier  String       @unique
  assetType          String    
  description        String?   
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  
  // New fields for asset lifecycle management
  status             AssetStatus  @default(PERMANENT)
  expiresAt          DateTime?    // For temporary file cleanup
  metadata           Json?        // Cache extracted data (colors, dimensions, etc.)
  
  systemIconsAsAsset SystemIcon[] 

  @@index([uploaderId])
  @@index([assetType])
  @@index([hostedUrl])
  @@index([status, expiresAt]) // For cleanup queries
}

model SystemIcon {
  id          String         @id @default(cuid())
  name        String         @unique
  category    String?
  svgContent  String?
  assetId     String?        @unique
  asset       UploadedAsset? @relation(fields: [assetId], references: [id], onDelete: SetNull)
  isAvailable Boolean        @default(true)
  description String?
  tags        String[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([name])
  @@index([category])
  @@index([isAvailable])
}

// --- GUILD CATEGORIES ---
model Category {
  id                 String   @id @default(cuid())
  name               String   @unique
  name_ci            String   @unique // Case-insensitive version for uniqueness
  description        String?
  isSystemCategory   Boolean  @default(false) // True if created by ViaGuild admins
  allowsGuildPrimary Boolean  @default(true) // True if users can mark a guild as 'primary' for this category
  parentId           String? // For hierarchical categories
  // creatorId           String?                 // User who created this category (if user-creatable)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  parent        Category?  @relation("SubCategories", fields: [parentId], references: [id], onDelete: SetNull)
  subcategories Category[] @relation("SubCategories")
  // creator             User?     @relation("UserCreatedCategories" fields: [creatorId], references: [id], onDelete:SetNull)

  guildsInCategories GuildCategory[] // Guilds associated with this category
  userPrimaryGuilds  UserCategoryPrimaryGuild[] // User designations of primary guilds in this category

  @@index([parentId])
}

model GuildCategory {
  guildId      String
  categoryId   String
  assignedAt   DateTime @default(now())
  assignedById String? // User ID of who assigned the guild to category (permission controlled)

  guild      Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  assignedBy User?    @relation("GuildCategoryAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@id([guildId, categoryId])
  @@index([guildId])
  @@index([categoryId])
}

model UserCategoryPrimaryGuild {
  userId     String
  categoryId String
  guildId    String // The guild the user has marked as primary for this category
  setAt      DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  guild    Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  // User must be a member of guildId, guildId must be in categoryId, and category.allowsGuildPrimary must be true.
  @@id([userId, categoryId]) // A user can only have one primary guild per category
  @@index([userId])
  @@index([categoryId])
  @@index([guildId])
}

// --- NOTIFICATION SYSTEM ---
model Notification {
  id        String           @id @default(uuid())
  userId    String // The user who receives the notification
  type      NotificationType
  title     String
  content   String           @db.Text
  linkUrl   String? // URL to relevant page when notification is clicked
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Contextual information about the notification
  sourceId   String? // ID of related entity (guild, badge, user, etc.)
  sourceType String? // Type of source ("guild", "badgeInstance", "user", "category")
  actorId    String? // User who triggered the notification (if applicable)

  recipient User  @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  actor     User? @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, isRead])
  @@index([createdAt])
}

// --- GUILD BAN MODEL ---
model GuildBan {
  id             String    @id @default(uuid())
  guildId        String // The guild that issued the ban
  bannedUserId   String // The user who was banned
  bannedByUserId String // The user who issued the ban
  reason         String?   @db.Text // Optional reason for the ban
  expiresAt      DateTime? // Null means permanent ban
  isActive       Boolean   @default(true)
  notes          String?   @db.Text // Additional context or notes
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relationships
  guild      Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  bannedUser User  @relation("BannedUser", fields: [bannedUserId], references: [id], onDelete: Cascade)
  bannedBy   User  @relation("BanIssuer", fields: [bannedByUserId], references: [id], onDelete: Restrict)

  // Indexes for efficient querying
  @@unique([guildId, bannedUserId]) // A user can only be banned once per guild
  @@index([guildId])
  @@index([bannedUserId])
  @@index([bannedByUserId])
  @@index([isActive])
  @@index([expiresAt])
}

// --- CLUSTER SYSTEM ---

model Cluster {
  id          String   @id @default(uuid())
  name        String   @unique
  name_ci     String   @unique // Case-insensitive version for uniqueness
  displayName String?
  description String?  @db.Text
  avatar      String? // URL to image storage
  isOpen      Boolean  @default(false) // True if guilds can join without approval
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator User @relation("ClusterCreator", fields: [createdById], references: [id], onDelete: Restrict)

  // Relationships - Members & Structure
  guildMemberships ClusterMembership[] // Guilds that are members of this cluster
  customRoles      ClusterRole[]       @relation("ClusterCustomRoles") // Custom roles for this cluster
  userRoles        UserClusterRole[] // New: User roles within this cluster

  // Relationships - Primary Designation
  primaryForGuilds Guild[] @relation("PrimaryClusterForGuilds")

  // Relationships - Badges
  badgeCase               ClusterBadgeCase? // Cluster's showcase of received badges
  contacts                ClusterContact[] // New: Contact links for the cluster

  // Relationships - Cluster Invitations & Join Requests (as source)
  directInvitationsToGuilds ClusterDirectInvitation[] @relation("InvitingCluster")
  joinRequestsFromGuilds    ClusterJoinRequest[]      @relation("TargetClusterForJoinRequest")

  roleSettings ClusterRoleSetting[] // ADDED Back-relation

  @@index([name])
}

model ClusterMembership {
  id        String   @id @default(uuid())
  guildId   String
  clusterId String
  joinedAt  DateTime @default(now())

  guild   Guild   @relation(fields: [guildId], references: [id], onDelete: Cascade)
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([guildId, clusterId])
  @@index([guildId])
  @@index([clusterId])
}

model ClusterRole {
  id           String   @id @default(cuid())
  name         String
  name_ci      String // Case-insensitive version
  description  String?
  clusterId    String? // Link to the specific cluster, optional for system roles
  isSystemRole Boolean  @default(false) // e.g., CLUSTER_CREATOR, CLUSTER_ADMIN
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  cluster                Cluster?                @relation("ClusterCustomRoles", fields: [clusterId], references: [id], onDelete: Cascade) // Made Cluster optional
  permissions            ClusterRolePermission[] // Link to the permissions this cluster role has
  assignedToClusterUsers UserClusterRole[]

  clusterSettings ClusterRoleSetting[] // ADDED Back-relation

  @@unique([clusterId, name_ci], name: "unique_cluster_role_name_ci")
  @@index([clusterId])
}

model UserClusterRole {
  id            String   @id @default(cuid())
  userId        String
  clusterId     String
  clusterRoleId String
  assignedAt    DateTime @default(now())
  // assignedById String? // User who assigned this cluster role

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cluster     Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("UserClusterRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, clusterId, clusterRoleId], name: "uniqueUserClusterRoleInCluster")
  @@index([userId])
  @@index([clusterId])
  @@index([clusterRoleId])
}

model ClusterBadgeCase {
  id              String   @id @default(uuid())
  clusterId       String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cluster       Cluster            @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  badges        ClusterBadgeItem[]
  featuredBadge ClusterBadgeItem?  @relation("FeaturedClusterBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model ClusterBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  ClusterBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance     @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn ClusterBadgeCase? @relation("FeaturedClusterBadgeInCase")

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model ClusterContact {
  id           String      @id @default(uuid())
  clusterId    String
  type         ContactType // Reusing the existing ContactType enum
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  cluster      Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, displayOrder])
}

model ClusterRolePermission {
  id            String   @id @default(cuid())
  clusterRoleId String
  permissionId  String
  assignedAt    DateTime @default(now())
  assignedById  String? // This field holds the ID of the User who assigned it

  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  permission  Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy  User?       @relation("ClusterRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull) // This relation uses assignedById

  @@unique([clusterRoleId, permissionId])
  @@index([clusterRoleId])
  @@index([permissionId])
  @@map("ClusterRolePermission")
}

// --- GUILD INVITATION SYSTEM ---

model GuildDirectInvitation {
  id                  String                @id @default(uuid())
  guildId             String
  invitedByUserId     String // User who sent the invitation
  targetUserId        String? // VG user who received the invitation (if they exist in ViaGuild system)
  targetUserHandle    String // The handle/username used for the invitation (e.g. "username123", "user@example.com")
  targetUserHandle_ci String // Case-insensitive version
  platform            InvitationPlatform // Platform of the targetUserHandle (e.g. VIAGUILD, TWITTER, DISCORD, etc.)
  status              GuildInvitationStatus @default(PENDING)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  expiresAt           DateTime? // Optional: For invitations that have a time limit

  guild         Guild @relation("InvitedToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  invitedByUser User  @relation("Inviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser    User? @relation("InvitedUser", fields: [targetUserId], references: [id], onDelete: SetNull) // Null if invited user is not yet on platform

  @@unique([guildId, targetUserHandle_ci, platform], name: "uniqueInvitationByHandle_ci")
  @@index([guildId])
  @@index([invitedByUserId])
  @@index([targetUserId])
  @@index([targetUserHandle, platform])
  @@index([status])
}

model GuildInvitationLink {
  id              String    @id @default(uuid()) // Can also be a unique string code if preferred over UUID
  guildId         String
  createdByUserId String
  code            String    @unique // The unique, shareable code for the link
  maxUses         Int? // Null for unlimited uses
  currentUses     Int       @default(0)
  expiresAt       DateTime? // Null for no expiration
  revokedAt       DateTime? // Timestamp if the link was manually revoked
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  guild         Guild @relation("LinkForGuild", fields: [guildId], references: [id], onDelete: Cascade)
  createdByUser User  @relation("LinkCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([createdByUserId])
  @@index([code])
}

model GuildJoinRequest {
  id               String                 @id @default(uuid())
  guildId          String
  userId           String // User requesting to join
  message          String?                @db.Text // Optional message from the user
  status           GuildJoinRequestStatus @default(PENDING)
  reviewedByUserId String? // Admin/Creator who reviewed the request
  reviewedAt       DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  guild          Guild @relation("RequestToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  requestingUser User  @relation("Requester", fields: [userId], references: [id], onDelete: Cascade)
  reviewedByUser User? @relation("Reviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([guildId, userId]) // User can only have one pending request per guild
  @@index([guildId])
  @@index([userId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- CLUSTER INVITATION & JOIN REQUEST SYSTEM ---

model ClusterDirectInvitation {
  id              String                        @id @default(uuid())
  clusterId       String // The cluster sending the invitation
  invitedByUserId String // User (cluster admin) who sent the invitation
  targetGuildId   String // The guild being invited
  status          ClusterDirectInvitationStatus @default(PENDING)
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime? // Optional: for invitations that have a time limit

  invitingCluster Cluster @relation("InvitingCluster", fields: [clusterId], references: [id], onDelete: Cascade)
  invitedByUser   User    @relation("ClusterInviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetGuild     Guild   @relation("TargetGuildForClusterInvitation", fields: [targetGuildId], references: [id], onDelete: Cascade)

  @@unique([clusterId, targetGuildId], name: "uniqueClusterToGuildInvitation")
  @@index([clusterId])
  @@index([invitedByUserId])
  @@index([targetGuildId])
  @@index([status])
}

model ClusterJoinRequest {
  id                String                   @id @default(uuid())
  clusterId         String // The cluster being requested to join
  requestingGuildId String // The guild making the request
  requestedByUserId String // User from the requesting guild who initiated the request
  message           String?                  @db.Text
  status            ClusterJoinRequestStatus @default(PENDING)
  reviewedByUserId  String? // User (cluster admin) who reviewed the request
  reviewedAt        DateTime?
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt

  targetCluster   Cluster @relation("TargetClusterForJoinRequest", fields: [clusterId], references: [id], onDelete: Cascade)
  requestingGuild Guild   @relation("RequestingGuildForClusterJoin", fields: [requestingGuildId], references: [id], onDelete: Cascade)
  requestedByUser User    @relation("ClusterJoinRequester", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  reviewedByUser  User?   @relation("ClusterJoinRequestReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([clusterId, requestingGuildId], name: "uniqueGuildToClusterJoinRequest")
  @@index([clusterId])
  @@index([requestingGuildId])
  @@index([requestedByUserId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- GUILD RELATIONSHIP PROPOSAL SYSTEM ---

model GuildRelationshipProposal {
  id                   String                     @id @default(uuid())
  proposingGuildId     String
  targetGuildId        String
  proposedType         RelationshipType
  status               RelationshipProposalStatus @default(PENDING)
  messageFromProposer  String?                    @db.Text
  messageFromResponder String?                    @db.Text
  proposedByUserId     String
  resolvedByUserId     String?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  expiresAt            DateTime?

  proposingGuild Guild @relation("ProposingGuildForRelationship", fields: [proposingGuildId], references: [id], onDelete: Cascade)
  targetGuild    Guild @relation("TargetGuildForRelationship", fields: [targetGuildId], references: [id], onDelete: Cascade)
  proposedByUser User  @relation("ProposedByUser", fields: [proposedByUserId], references: [id], onDelete: Cascade)
  resolvedByUser User? @relation("ResolvedByUser", fields: [resolvedByUserId], references: [id], onDelete: SetNull)

  @@unique([proposingGuildId, targetGuildId, proposedType, status], name: "unique_pending__guild_relationship_proposal")
  @@index([proposingGuildId])
  @@index([targetGuildId])
  @@index([status])
  @@index([proposedByUserId])
  @@index([resolvedByUserId])
}

// ADD THE NEW ClusterRoleSetting MODEL
model ClusterRoleSetting {
  id            String @id @default(cuid())
  clusterId     String
  clusterRoleId String // Foreign key to ClusterRole table

  hierarchyOrder  Int // Defines hierarchical power within this cluster, lower is higher
  displaySequence Int? // Optional: For visual sorting in this cluster's UI

  overrideRoleName     String? // Cluster-specific display name for this role
  overrideDisplayColor String? // Cluster-specific color for this role

  isFeatured Boolean @default(false) // If true, this ROLE TYPE is featured in this cluster

  assignedById String? // Optional: who configured this setting

  cluster    Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  role       ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  assignedBy User?       @relation("ClusterRoleSettingAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([clusterId, clusterRoleId])
  @@index([clusterId, hierarchyOrder])
  @@index([clusterId, displaySequence])
  @@index([clusterRoleId])
  @@map("ClusterRoleSetting")
}
