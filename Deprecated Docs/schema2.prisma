// This is your Prisma schema file
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---

enum GuildMemberRank {
  S
  A
  B
  C
  D
  E // Default rank
}

enum RelationshipType {
  PARENT // Defines a hierarchical relationship where sourceGuildId is parent, targetGuildId is child
  PARTNER
  RIVAL
  // WAR // Example for future unilateral type
}

enum ContactType {
  WEBSITE
  EMAIL
  DISCORD
  TWITTER
  BLUESKY
  TWITCH
  GITHUB
  LINKEDIN
  CUSTOM
}

enum BadgeShape {
  CIRCLE
  STAR
  HEART
  HEXAGON
  SQUARE
}

enum BadgeTier {
  GOLD
  SILVER
  BRONZE
}

// --- Configuration Enums (for validating JSON content in application logic) ---

enum BackgroundContentType {
  SOLID_COLOR     // The 'value' will be a hex color string.
  HOSTED_IMAGE    // The 'value' will be a hostedUrl from an UploadedAsset.
}

enum ForegroundContentType {
  TEXT            // The 'value' will be a string of text.
  SYSTEM_ICON     // The 'value' will be an id or unique name referencing a SystemIcon record.
  UPLOADED_ICON   // The 'value' will be a hostedUrl from an UploadedAsset (typically an SVG or small raster icon).
}

// Optional: Describes a predefined visual style for text elements (e.g., metadata fields or even foreground text).
// These would correspond to CSS classes or styling logic in your frontend.
// enum TextStyle {
//   METADATA_DEFAULT
//   METADATA_HIGHLIGHT
//   FOREGROUND_TITLE // Example if foreground text has specific styling options
//   // ... etc.
// }
// --- END Configuration Enums ---

enum NotificationType {
  GUILD_INVITE
  BADGE_RECEIVED
  GUILD_JOIN_REQUEST
  RELATIONSHIP_REQUEST // This might be deprecated or reused for general relationship updates
  GUILD_UPDATE
  NEW_GUILD_MEMBER
  ROLE_ASSIGNED
  RANK_UPDATED
  CATEGORY_PRIMARY_SET

  // Guild Relationship Proposal Notifications
  GUILD_RELATIONSHIP_PROPOSAL_RECEIVED
  GUILD_RELATIONSHIP_PROPOSAL_ACCEPTED
  GUILD_RELATIONSHIP_PROPOSAL_REJECTED
  GUILD_RELATIONSHIP_PROPOSAL_REVOKED
  GUILD_RELATIONSHIP_PROPOSAL_EXPIRED
  // Add more as new features arise
}

// --- Guild Invitation System Enums ---
enum GuildInvitationStatus {
  PENDING // Invitation sent, awaiting response
  ACCEPTED // Invitation accepted, user is now a member or will be processed as one
  REJECTED // Invitation explicitly rejected by the target
  EXPIRED // Invitation expired due to time limit (if applicable)
  REVOKED // Invitation withdrawn by guild admin/owner
  CONSUMED // Invitation automatically processed (e.g., due to new social link or joining via another means)
}

enum InvitationPlatform {
  VIAGUILD // ViaGuild username
  TWITTER
  BLUESKY
  TWITCH
  DISCORD
  // EMAIL // Potentially for future use
  // OTHER // Generic for unlisted platforms
}

enum GuildJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- Cluster Invitation/Join Request System Enums ---
enum ClusterDirectInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED
  EXPIRED // Optional: if cluster-to-guild invites can expire
}

enum RelationshipProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  REVOKED // By the proposer
  EXPIRED
  SUPERSEDED // When another proposal between the same guilds is accepted
}

enum ClusterJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// --- CORE MODELS ---

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  username       String   @unique // Unique handle
  displayName    String? // For display purposes
  passwordHash   String
  bio            String?
  avatar         String? // Base64 encoded image data or file path (Can eventually become a hostedUrl from UploadedAsset)
  isPublic       Boolean  @default(true)
  hiddenAccounts String[] @default([]) // Array of social account IDs to hide
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships - Permissions & Roles
  systemRoles UserSystemRole[]

  // Relationships - Social & Guilds
  socialAccounts   SocialAccount[]
  createdGuilds    Guild[]           @relation("GuildCreator")
  updatedGuilds    Guild[]           @relation("GuildUpdater") // Guilds last updated by this user
  guildMemberships GuildMembership[]
  // createdRelationships GuildRelationship[] @relation("RelationshipCreator") // Guild relationships created by this user // REMOVED

  // Guild Relationships - as proposer or accepter
  proposedGuildRelationships GuildRelationship[] @relation("RelationshipProposer")
  acceptedGuildRelationships GuildRelationship[] @relation("RelationshipAccepter")

  // Guild Relationship Proposals - as initiator or resolver
  initiatedGuildRelationshipProposals GuildRelationshipProposal[] @relation("ProposedByUser")
  resolvedGuildRelationshipProposals  GuildRelationshipProposal[] @relation("ResolvedByUser")

  // --- MODIFIED Badge Relationships ---
  givenBadgesAsUser    BadgeInstance[]       @relation("UserGivenBadges") // Badges given directly by this user
  receivedBadgesAsUser BadgeInstance[]       @relation("UserReceivedBadges") // Badges received directly by this user
  
  authoredBadgeTemplates BadgeTemplate[]     @relation("AuthoredByRelation") // Templates this user physically created/designed
  ownedBadgeTemplates    BadgeTemplate[]     @relation("UserOwnedBadgeTemplates")  // Templates this user explicitly owns

  badgeAllocations     UserBadgeAllocation[] // Tiered badge allocations for this user
  badgeCase            UserBadgeCase?        // User's personal showcase of received badges
  uploadedAssets       UploadedAsset[]       @relation("UserUploadedAssets") // Assets uploaded by this user
  // --- END MODIFIED Badge Relationships ---

  // Relationships - Categories
  primaryGuildsPerCategory UserCategoryPrimaryGuild[] // User's designated primary guilds for specific categories
  // createdCategories         Category[]              @relation("UserCreatedCategories") // If users can create categories

  // Relationships - Notifications
  notifications      Notification[] @relation("NotificationRecipient")
  actorNotifications Notification[] @relation("NotificationActor") // Notifications where this user was the actor

  // Add these relations
  bansReceived GuildBan[] @relation("BannedUser")
  bansIssued   GuildBan[] @relation("BanIssuer")

  // Relations for audit trails (who assigned what)
  rolePermissionsAssigned       RolePermission[]         @relation("RolePermissionAssignedBy")
  systemRolesAssigned           UserSystemRole[]         @relation("UserSystemRoleAssignedBy")
  guildBadgeAssignmentsActioned GuildAssignmentDetails[] @relation("GuildAssignmentDetailsAssignedBy")
  guildCategoriesAssigned       GuildCategory[]          @relation("GuildCategoryAssignedBy")

  // Relationships - Clusters
  createdClusters Cluster[]         @relation("ClusterCreator")
  clusterRoles    UserClusterRole[] // Roles held by the user in various clusters

  // Relationships - Guild Invitations & Join Requests
  sentGuildDirectInvitations     GuildDirectInvitation[] @relation("Inviter")
  receivedGuildDirectInvitations GuildDirectInvitation[] @relation("InvitedUser")
  createdGuildInvitationLinks    GuildInvitationLink[]   @relation("LinkCreator")
  guildJoinRequests              GuildJoinRequest[]      @relation("Requester")
  reviewedGuildJoinRequests      GuildJoinRequest[]      @relation("Reviewer")

  // Relationships - Cluster Invitations & Join Requests (as initiator/reviewer)
  sentClusterDirectInvitations ClusterDirectInvitation[] @relation("ClusterInviter")
  initiatedClusterJoinRequests ClusterJoinRequest[]      @relation("ClusterJoinRequester")
  reviewedClusterJoinRequests  ClusterJoinRequest[]      @relation("ClusterJoinRequestReviewer")
}

model SocialAccount {
  id                   String   @id @default(uuid())
  provider             String // "twitter", "bluesky", "twitch", "discord"
  providerId           String // ID from the provider
  username             String // Username from the provider
  encryptedCredentials String? // Encrypted app password or OAuth token for future use (e.g. posting on their behalf)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([provider, providerId])
  @@index([userId])
}

model Guild {
  id                String   @id @default(uuid())
  name              String   @unique // Unique handle/slug for the guild
  displayName       String? // For display purposes
  description       String   @db.Text
  avatar            String? // URL to image storage (Can eventually become a hostedUrl from UploadedAsset)
  isOpen            Boolean  @default(false) // If true, users can join automatically without needing permission/invitation.
  allowJoinRequests Boolean  @default(true) // If true, users can submit requests to join this guild (moderated).
  createdById       String
  updatedById       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationships - Creator/Updater
  creator   User  @relation("GuildCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy User? @relation("GuildUpdater", fields: [updatedById], references: [id], onDelete: SetNull)

  // Relationships - Members & Structure
  memberships GuildMembership[]
  roles       Role[]            @relation("GuildCustomRoles") // Custom roles defined for this guild
  contacts    GuildContact[]

  // --- MODIFIED Badge Relationships ---
  givenBadgesAsGuild    BadgeInstance[] @relation("GuildGivenBadges") // Badges given by this guild as an entity
  receivedBadgesAsGuild BadgeInstance[] @relation("GuildReceivedBadges") // Badges received by this guild as an entity
  ownedBadgeTemplates   BadgeTemplate[] @relation("GuildOwnedBadgeTemplates") // Badge templates "owned" or designed by this guild
  badgeCase             GuildBadgeCase? // Guild's showcase of received badges
  // --- END MODIFIED Badge Relationships ---

  // Relationships - Inter-Guild
  outgoingRelationships GuildRelationship[] @relation("SourceRelationships")
  incomingRelationships GuildRelationship[] @relation("TargetRelationships")

  // Relationships - Inter-Guild Proposals
  sentRelationshipProposals     GuildRelationshipProposal[] @relation("ProposingGuildForRelationship")
  receivedRelationshipProposals GuildRelationshipProposal[] @relation("TargetGuildForRelationship")

  // Relationships - Categories
  categories                    GuildCategory[] // Categories this guild belongs to
  designatedAsPrimaryInCategory UserCategoryPrimaryGuild[] // Instances where this guild is marked primary for a category by users

  // Relationships - Clusters
  primaryClusterId   String?             @unique // Optional: A guild can have one primary cluster
  primaryCluster     Cluster?            @relation("PrimaryClusterForGuilds", fields: [primaryClusterId], references: [id], onDelete: SetNull)
  clusterMemberships ClusterMembership[] // Guilds that are members of this cluster

  // Add this relation
  bans GuildBan[]

  // Relationships - Guild Invitations & Join Requests
  directInvitations GuildDirectInvitation[] @relation("InvitedToGuild")
  invitationLinks   GuildInvitationLink[]   @relation("LinkForGuild")
  joinRequests      GuildJoinRequest[]      @relation("RequestToGuild")

  // Relationships - Cluster System (as target of invite or requester of join)
  receivedClusterDirectInvitations ClusterDirectInvitation[] @relation("TargetGuildForClusterInvitation")
  sentClusterJoinRequests          ClusterJoinRequest[]      @relation("RequestingGuildForClusterJoin")

  @@index([name])
  @@index([primaryClusterId])
}

// --- PERMISSION SYSTEM ---

model Permission {
  id              String   @id @default(cuid())
  key             String   @unique // e.g., "GUILD_KICK_MEMBER", "BADGE_TEMPLATE_CREATE_GUILD"
  description     String?
  permissionGroup String? // For UI grouping, e.g., "Guild Management", "Badge Administration"
  createdAt       DateTime @default(now())

  rolePermissions        RolePermission[]
  clusterRolePermissions ClusterRolePermission[] // New: For cluster roles

  @@index([key])
}

model Role {
  id            String   @id @default(cuid())
  name          String // e.g., "Owner", "Admin", "Member", "Treasurer", "SuperAdmin"
  description   String?
  guildId       String? // If null, it's a system-level role. If set, it's a custom role for that specific guild.
  isSystemRole  Boolean  @default(false) // True for ViaGuild predefined roles (Owner, Admin, Member, SuperAdmin)
  isDefaultRole Boolean  @default(false) // e.g., new guild members get this role by default for their guild
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  guild            Guild?            @relation("GuildCustomRoles", fields: [guildId], references: [id], onDelete: Cascade)
  permissions      RolePermission[]
  guildMemberships GuildMembership[]
  systemUsers      UserSystemRole[]

  @@unique([name, guildId])
  @@index([guildId])
}

model RolePermission {
  id           String   @id @default(cuid())
  roleId       String
  permissionId String
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this permission to the role (for auditing)

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  assignedBy User?      @relation("RolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserSystemRole {
  id           String   @id @default(cuid())
  userId       String
  roleId       String // Must be a Role where guildId is null and isSystemRole is true
  assignedAt   DateTime @default(now())
  assignedById String? // User who assigned this system role

  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role  @relation(fields: [roleId], references: [id], onDelete: Cascade) // Should point to a system role
  assignedBy User? @relation("UserSystemRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// --- GUILD STRUCTURE & MEMBERSHIP ---

model GuildMembership {
  id           String          @id @default(uuid())
  userId       String
  guildId      String
  roleId       String // Points to an entry in the Role table
  isPrimary    Boolean         @default(false) // Global primary guild for the user
  primarySetAt DateTime? // When this guild was set as primary
  rank         GuildMemberRank @default(E)
  joinedAt     DateTime        @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  role  Role  @relation(fields: [roleId], references: [id], onDelete: Restrict) // Don't delete role if in use

  @@unique([userId, guildId], name: "uniqueUserGuild")
  @@index([userId])
  @@index([guildId])
  @@index([roleId])
  @@index([userId, isPrimary])
}

model GuildRelationship {
  id             String           @id @default(uuid())
  sourceGuildId  String
  targetGuildId  String
  type           RelationshipType
  // createdById   String // User who created the relationship // REMOVED
  proposerUserId String? // User who initiated the proposal or unilateral action
  accepterUserId String? // User who accepted a proposal; nullable for unilateral actions
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  sourceGuild  Guild @relation("SourceRelationships", fields: [sourceGuildId], references: [id], onDelete: Cascade)
  targetGuild  Guild @relation("TargetRelationships", fields: [targetGuildId], references: [id], onDelete: Cascade)
  // creator     User  @relation("RelationshipCreator", fields: [createdById], references: [id], onDelete: Restrict) // REMOVED
  proposerUser User? @relation("RelationshipProposer", fields: [proposerUserId], references: [id], onDelete: SetNull)
  accepterUser User? @relation("RelationshipAccepter", fields: [accepterUserId], references: [id], onDelete: SetNull)

  @@unique([sourceGuildId, targetGuildId])
  @@index([sourceGuildId])
  @@index([targetGuildId])
}

model GuildContact {
  id           String      @id @default(uuid())
  guildId      String
  type         ContactType
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  guild Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, displayOrder])
}

// --- BADGE SYSTEM ---

model BadgeTemplate {
  id                   String  @id @default(uuid())
  baseName             String  // Default base name, can be overridden by dynamicDisplayConfig.badgeName
  baseSubtitle         String? // Default base subtitle, can be overridden by dynamicDisplayConfig.subtitle
  description          String? @db.Text // General description of the template's purpose

  // --- Ownership and Creation ---
  // User who physically designed/inputted this template. Nullable for system-generated.
  authoredByUserId     String?
  authoredByUser       User?   @relation("AuthoredByRelation", fields: [authoredByUserId], references: [id], onDelete: SetNull)

  // Explicit user owner. Mutually exclusive with ownedByGuildId.
  ownedByUserId        String?
  ownedByUser          User?   @relation("UserOwnedBadgeTemplates", fields: [ownedByUserId], references: [id], onDelete: SetNull)

  // Explicit guild owner. Mutually exclusive with ownedByUserId.
  ownedByGuildId       String?
  ownedByGuild         Guild?  @relation("GuildOwnedBadgeTemplates", fields: [ownedByGuildId], references: [id], onDelete: SetNull)

  // --- Behavior Control & Lifecycle ---
  isArchived           Boolean @default(false) // If true, template is archived and not available for new badge awards
  isModifiableByIssuer Boolean @default(false) // If true, issuer can update this template's core props (like dynamicDisplayConfig or baseName), affecting all instances.
  allowsPushedInstanceUpdates Boolean @default(false) // If true, issuer can push updates to instanceData of badges awarded from this template AFTER initial award, affecting one specific instance.

  // dynamicDisplayConfig: Defines the rendering rules and how instanceData is used.
  // Structure:
  // {
  //   "badgeName": { // How the badge's display name is determined
  //     "default": "string (Default display name, template.baseName can be a fallback if this is empty)",
  //     // Rendering engine will look for "override_badgeName" in instanceData for the text content
  //   },
  //   "subtitle": { // Optional subtitle text on the badge. Font, color, and size are typically predefined by the template's overall style for subtitles.
  //     "default": "string (Default subtitle, template.baseSubtitle can be a fallback if this is empty)",
  //     // Rendering engine will look for "override_subtitleText" (or "override_subtitle") in instanceData for the text content
  //   },
  //   "displayDescription": { // User-facing description shown on badge detail page or rich views
  //     "default": "string (Default detailed description for this badge type)",
  //     // Rendering engine will look for "override_displayDescription" in instanceData
  //   },
  //   "outerShape": {
  //     "default": "CIRCLE", // Expects a BadgeShape enum string (e.g., CIRCLE, STAR, HEXAGON, HEART, SQUARE)
  //     // Rendering engine will look for e.g. "override_outerShape" in instanceData
  //   },
  //   "borderColor": {
  //     "default": "#RRGGBB (hex color)"
  //     // Rendering engine will look for e.g. "override_borderColor" in instanceData
  //   },
  //   "background": {
  //     "type": { // Defines how the background is sourced
  //       "default": "SOLID_COLOR" // Expects a BackgroundContentType ENUM string.
  //       // Rendering engine will look for e.g. "override_bgType" in instanceData
  //     },
  //     "value": { // The actual color hex or hosted_image_url
  //       "default": "#RRGGBB or hosted_image_url_string",
  //       // Rendering engine will look for e.g. "override_bgValue" in instanceData
  //     }
  //   },
  //   "foreground": { // Primary element on the badge (icon or text)
  //     "type": { // Defines how the foreground is sourced
  //       "default": "SYSTEM_ICON" // Expects a ForegroundContentType ENUM string.
  //       // Rendering engine will look for e.g. "override_fgType" in instanceData
  //     },
  //     "value": { // The actual text content or hosted_icon_url
  //       "default": "string (for TEXT) or system_icon_id (for SYSTEM_ICON) or uploaded_asset_hosted_url (for UPLOADED_ICON)",
  //       // Rendering engine will look for e.g. "override_fgValue" in instanceData
  //     },
  //     "color": { // Color for the text or icon tint
  //       "default": "#333333", // Example default foreground color
  //       // Rendering engine will look for e.g. "override_foregroundColor" in instanceData
  //     },
  //     "textFont": { // Only applicable if foreground.type is TEXT
  //       "default": "FONT_NAME_FROM_APPROVED_LIST (string)",
  //       // Rendering engine will look for e.g. "override_textFont" in instanceData
  //     },
  //     "textSize": { // Only applicable if foreground.type is TEXT
  //       "default": font size (int),
  //       // Rendering engine will look for e.g. "override_fgSize" in instanceData
  //     }  
  //   },
  //   "instanceTextFields": [ // Array of objects, each defining a text slot for METADATA (tooltips, detail pages)
  //     {
  //       "fieldKeyInInstanceData": "string (key in instanceData for this field's value, e.g., 'achievement')",
  //       "label": "string (Static label, e.g., 'Achieved:')",
  //       // "labelPath": "string (Optional: key in instanceData for a dynamic label)",
  //       "prefix": "string (Optional)",
  //       "suffix": "string (Optional)",
  //       "style": "string (Predefined style name for metadata display, e.g., 'METADATA_DEFAULT', from TextStyle enum if used)",
  //       "displayOrder": "integer (e.g., 0, 1, 2... lower numbers displayed first)"
  //       // --- For fields intended to provide programmatic credentials and access control ---
  //       // "isCredentialValue": "boolean (default: false, ideally only one field per template is true)",
  //       // "credentialValueBest": "number (e.g., 1 for rank, 10000 for score if higher is better)",
  //       // "credentialValueWorst": "number (e.g., 100 for rank, 0 for score if higher is better)",
  //       //   Rule: If credentialValueWorst > credentialValueBest, then lower actual values are better.
  //       //   Rule: If credentialValueBest > credentialValueWorst, then higher actual values are better.
  //       // "credentialValueDescription": "string (Explains what this numeric credential represents, e.g., 'Competitive tier; lower is best.')",
  //       // "canBeNormalized": "boolean (optional, default: false or true if best/worst define a range (i.e. they're not the same number). Hints if value can be normalized to 0-1 scale)"
  //     }
  //     // ... more text field definitions ...
  //   ]
  // }
  dynamicDisplayConfig Json?

  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  instances BadgeInstance[]

  // A template should be user-owned, guild-owned, or system (all owner fields null).
  // Application logic should enforce that ownedByUserId and ownedByGuildId are mutually exclusive.
  @@index([authoredByUserId])
  @@index([ownedByUserId])
  @@index([ownedByGuildId])
  @@index([isArchived])
  @@index([isModifiableByIssuer])
  @@index([allowsPushedInstanceUpdates])
}

model BadgeInstance {
  id         String    @id @default(uuid())
  templateId String
  assignedAt DateTime  @default(now())
  revokedAt  DateTime?
  message    String?   @db.Text // Optional message from the giver or context of assignment

  // --- Giver (Polymorphic: User or Guild) ---
  userGiverId  String?
  guildGiverId String?
  // clusterGiverId String? // Future: If clusters can give badges

  // --- Receiver (Polymorphic: User or Guild or Cluster) ---
  userReceiverId    String?
  guildReceiverId   String?
  clusterReceiverId String? // New: Cluster as a receiver

  // --- Instance Specific Data ---
  // Provides specific values for the dynamic parts defined by
  // the associated BadgeTemplate's dynamicDisplayConfig.
  // Structure: Key-value pairs. Keys should match those specified in
  // dynamicDisplayConfig's "fieldKeyInInstanceData" for instanceTextFields,
  // OR platform-defined conventional override keys (e.g., "override_borderColor").
  // Example:
  // {
  //   "override_borderColor": "#FF0000", 
  //   "override_backgroundValue": "https://yourcdn.com/specific_bg.png", // This would be an UploadedAsset.hostedUrl
  //   "achievement": "Completed the tutorial!" // Value for an instanceTextField where fieldKeyInInstanceData was "achievement"
  // }
  instanceData Json?

  guildAssignmentDetails GuildAssignmentDetails? @relation("BadgeInstanceToGuildAssignmentDetails")

  // Relationships
  template        BadgeTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict) // IMPORTANT: Prevents template deletion if instances exist
  userGiver       User?         @relation("UserGivenBadges", fields: [userGiverId], references: [id], onDelete: SetNull)
  guildGiver      Guild?        @relation("GuildGivenBadges", fields: [guildGiverId], references: [id], onDelete: SetNull)
  // clusterGiver    Cluster?      @relation("ClusterGivenBadges", fields: [clusterGiverId], references: [id], onDelete: SetNull) // Future
  userReceiver    User?         @relation("UserReceivedBadges", fields: [userReceiverId], references: [id], onDelete: Cascade)
  guildReceiver   Guild?        @relation("GuildReceivedBadges", fields: [guildReceiverId], references: [id], onDelete: Cascade)
  clusterReceiver Cluster?      @relation("ClusterReceivedBadges", fields: [clusterReceiverId], references: [id], onDelete: Cascade) // New

  // Links to Badge Case Items
  userBadgeItem     UserBadgeItem?
  guildBadgeItems   GuildBadgeItem[]
  clusterBadgeItems ClusterBadgeItem[] // New: links to showcases where this badge instance is displayed

  // CHECK constraint (conceptual, enforce in application logic):
  // 1. (userGiverId != null XOR guildGiverId != null XOR clusterGiverId != null) // Consider clusterGiver later
  // 2. (userReceiverId != null XOR guildReceiverId != null XOR clusterReceiverId != null)
  // 3. If guildGiverId is set, detailsOfGuildAssignmentId can be set.

  @@index([templateId])
  @@index([userGiverId])
  @@index([guildGiverId])
  @@index([userReceiverId])
  @@index([guildReceiverId])
  @@index([clusterReceiverId]) // New
}

model GuildAssignmentDetails {
  id              String        @id @default(uuid())
  badgeInstanceId String        @unique // Link back to the BadgeInstance
  badgeInstance   BadgeInstance @relation("BadgeInstanceToGuildAssignmentDetails", fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  assignmentMethod String? // e.g., "MEMBER_VOTE", "ADMIN_DECISION", "AUTOMATED_MILESTONE"
  voteRecordId     String? // If applicable, link to a vote record elsewhere
  approvalChain    Json? // Store who approved it, if a multi-step process
  notes            String? @db.Text
  assignedByUserId String? // User who actioned this guild assignment (if applicable)

  assignedByUser User? @relation("GuildAssignmentDetailsAssignedBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([badgeInstanceId])
}

model UserBadgeAllocation {
  id                String    @id @default(uuid())
  userId            String
  tier              BadgeTier // e.g., GOLD, SILVER, BRONZE
  remaining         Int       @default(0)
  lastReplenishedAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tier])
  @@index([userId])
}

model UserBadgeCase {
  id        String   @id @default(uuid())
  userId    String   @unique
  title     String?
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  badges UserBadgeItem[]
}

model UserBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String   @unique // Added @unique
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase UserBadgeCase @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge     BadgeInstance @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

model GuildBadgeCase {
  id              String   @id @default(uuid())
  guildId         String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique // Optional featured badge for special display
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  guild         Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)
  badges        GuildBadgeItem[]
  featuredBadge GuildBadgeItem?  @relation("FeaturedGuildBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model GuildBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  GuildBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance   @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn GuildBadgeCase? @relation("FeaturedGuildBadgeInCase") // Link back if this item is the featured one

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

// --- GUILD CATEGORIES ---

model Category {
  id                 String   @id @default(cuid())
  name               String   @unique
  description        String?
  isSystemCategory   Boolean  @default(false) // True if created by ViaGuild admins
  allowsGuildPrimary Boolean  @default(true) // True if users can mark a guild as 'primary' for this category
  parentId           String? // For hierarchical categories
  // creatorId           String?                 // User who created this category (if user-creatable)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  parent        Category?  @relation("SubCategories", fields: [parentId], references: [id], onDelete: SetNull)
  subcategories Category[] @relation("SubCategories")
  // creator             User?     @relation("UserCreatedCategories" fields: [creatorId], references: [id], onDelete:SetNull)

  guildsInCategories GuildCategory[] // Guilds associated with this category
  userPrimaryGuilds  UserCategoryPrimaryGuild[] // User designations of primary guilds in this category

  @@index([parentId])
}

model GuildCategory {
  guildId      String
  categoryId   String
  assignedAt   DateTime @default(now())
  assignedById String? // User ID of who assigned the guild to category (permission controlled)

  guild      Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  assignedBy User?    @relation("GuildCategoryAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@id([guildId, categoryId])
  @@index([guildId])
  @@index([categoryId])
}

model UserCategoryPrimaryGuild {
  userId     String
  categoryId String
  guildId    String // The guild the user has marked as primary for this category

  setAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  guild    Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  // User must be a member of guildId, guildId must be in categoryId, and category.allowsGuildPrimary must be true.
  @@id([userId, categoryId]) // A user can only have one primary guild per category
  @@index([userId])
  @@index([categoryId])
  @@index([guildId])
}

// --- NOTIFICATION SYSTEM ---

model Notification {
  id        String           @id @default(uuid())
  userId    String // The user who receives the notification
  type      NotificationType
  title     String
  content   String           @db.Text
  linkUrl   String? // URL to relevant page when notification is clicked
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Contextual information about the notification
  sourceId   String? // ID of related entity (guild, badge, user, etc.)
  sourceType String? // Type of source ("guild", "badgeInstance", "user", "category")
  actorId    String? // User who triggered the notification (if applicable)

  recipient User  @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  actor     User? @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, isRead])
  @@index([createdAt])
}

// Add the new GuildBan model
model GuildBan {
  id             String    @id @default(uuid())
  guildId        String // The guild that issued the ban
  bannedUserId   String // The user who was banned
  bannedByUserId String // The user who issued the ban
  reason         String?   @db.Text // Optional reason for the ban
  expiresAt      DateTime? // Null means permanent ban
  isActive       Boolean   @default(true)
  notes          String?   @db.Text // Additional context or notes
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relationships
  guild      Guild @relation(fields: [guildId], references: [id], onDelete: Cascade)
  bannedUser User  @relation("BannedUser", fields: [bannedUserId], references: [id], onDelete: Cascade)
  bannedBy   User  @relation("BanIssuer", fields: [bannedByUserId], references: [id], onDelete: Restrict)

  // Indexes for efficient querying
  @@unique([guildId, bannedUserId]) // A user can only be banned once per guild
  @@index([guildId])
  @@index([bannedUserId])
  @@index([bannedByUserId])
  @@index([isActive])
  @@index([expiresAt])
}

// --- CLUSTER SYSTEM ---

model Cluster {
  id          String   @id @default(uuid())
  name        String   @unique // Unique handle/slug for the cluster
  displayName String? // For display purposes
  description String?  @db.Text
  avatar      String? // URL to image storage
  isOpen      Boolean  @default(false) // True if guilds can join without approval
  createdById String // User who created the cluster
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator User @relation("ClusterCreator", fields: [createdById], references: [id], onDelete: Restrict)

  // Relationships - Members & Structure
  guildMemberships ClusterMembership[] // Guilds that are members of this cluster
  roles            ClusterRole[]       @relation("ClusterCustomRoles") // Custom roles for this cluster
  userRoles        UserClusterRole[] // New: User roles within this cluster

  // Relationships - Primary Designation
  primaryForGuilds Guild[] @relation("PrimaryClusterForGuilds")

  // Relationships - Badges
  receivedBadgesAsCluster BadgeInstance[]   @relation("ClusterReceivedBadges") // Badges received by this cluster
  badgeCase               ClusterBadgeCase? // Cluster's showcase of received badges
  contacts                ClusterContact[] // New: Contact links for the cluster

  // Relationships - Cluster Invitations & Join Requests (as source)
  directInvitationsToGuilds ClusterDirectInvitation[] @relation("InvitingCluster")
  joinRequestsFromGuilds    ClusterJoinRequest[]      @relation("TargetClusterForJoinRequest")

  @@index([name])
}

model ClusterMembership {
  id        String   @id @default(uuid())
  guildId   String
  clusterId String
  joinedAt  DateTime @default(now())

  guild   Guild   @relation(fields: [guildId], references: [id], onDelete: Cascade)
  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@unique([guildId, clusterId])
  @@index([guildId])
  @@index([clusterId])
}

model ClusterRole {
  id           String   @id @default(cuid())
  name         String
  description  String?
  clusterId    String? // Link to the specific cluster, optional for system roles
  isSystemRole Boolean  @default(false) // e.g., CLUSTER_OWNER, CLUSTER_ADMIN
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  cluster          Cluster?                @relation("ClusterCustomRoles", fields: [clusterId], references: [id], onDelete: Cascade) // Made Cluster optional
  permissions      ClusterRolePermission[] // Link to the permissions this cluster role has
  userClusterRoles UserClusterRole[]

  @@unique([name, clusterId])
  @@index([clusterId])
}

model UserClusterRole {
  id            String   @id @default(cuid())
  userId        String
  clusterId     String // To identify the cluster context directly
  clusterRoleId String
  assignedAt    DateTime @default(now())
  // assignedById String? // User who assigned this cluster role

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cluster     Cluster     @relation(fields: [clusterId], references: [id], onDelete: Cascade) // Direct link to Cluster
  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("UserClusterRoleAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([userId, clusterId, clusterRoleId], name: "uniqueUserClusterRoleInCluster")
  @@index([userId])
  @@index([clusterId])
  @@index([clusterRoleId])
}

model ClusterBadgeCase {
  id              String   @id @default(uuid())
  clusterId       String   @unique
  title           String?
  isPublic        Boolean  @default(true)
  featuredBadgeId String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cluster       Cluster            @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  badges        ClusterBadgeItem[]
  featuredBadge ClusterBadgeItem?  @relation("FeaturedClusterBadgeInCase", fields: [featuredBadgeId], references: [id], onDelete: SetNull)
}

model ClusterBadgeItem {
  id              String   @id @default(uuid())
  badgeCaseId     String
  badgeInstanceId String
  displayOrder    Int      @default(0)
  addedAt         DateTime @default(now())

  badgeCase  ClusterBadgeCase  @relation(fields: [badgeCaseId], references: [id], onDelete: Cascade)
  badge      BadgeInstance     @relation(fields: [badgeInstanceId], references: [id], onDelete: Cascade)
  featuredIn ClusterBadgeCase? @relation("FeaturedClusterBadgeInCase")

  @@unique([badgeCaseId, badgeInstanceId])
  @@index([badgeCaseId, displayOrder])
}

// New model for Cluster Contacts
model ClusterContact {
  id           String      @id @default(uuid())
  clusterId    String
  type         ContactType // Reusing the existing ContactType enum
  label        String? // For custom contact types
  value        String // The actual contact info (URL, username, etc.)
  displayOrder Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  cluster Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, displayOrder])
}

// New model for linking ClusterRoles to Permissions
model ClusterRolePermission {
  id            String   @id @default(cuid())
  clusterRoleId String
  permissionId  String
  assignedAt    DateTime @default(now())
  // assignedById  String?  // Optional: User who assigned this permission to the cluster role (for auditing)

  clusterRole ClusterRole @relation(fields: [clusterRoleId], references: [id], onDelete: Cascade)
  permission  Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  // assignedBy  User?       @relation("ClusterRolePermissionAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([clusterRoleId, permissionId])
  @@index([clusterRoleId])
  @@index([permissionId])
}

// --- GUILD INVITATION SYSTEM ---

model GuildDirectInvitation {
  id               String                @id @default(uuid())
  guildId          String
  invitedByUserId  String // User who sent the invitation
  targetUserId     String? // User who received the invitation (if they exist in ViaGuild system)
  targetUserHandle String // The handle/username used for the invitation (e.g. "username123", "user@example.com")
  platform         InvitationPlatform // Platform of the targetUserHandle (e.g. VIAGUILD, TWITTER, DISCORD)
  status           GuildInvitationStatus @default(PENDING)
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  expiresAt        DateTime? // Optional: For invitations that have a time limit

  guild         Guild @relation("InvitedToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  invitedByUser User  @relation("Inviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser    User? @relation("InvitedUser", fields: [targetUserId], references: [id], onDelete: SetNull) // Null if invited user is not yet on platform

  @@unique([guildId, targetUserHandle, platform], name: "uniqueInvitationByHandle") // Prevent duplicate invites to the same handle for the same guild
  @@index([guildId])
  @@index([invitedByUserId])
  @@index([targetUserId])
  @@index([targetUserHandle, platform])
  @@index([status])
}

model GuildInvitationLink {
  id              String    @id @default(uuid()) // Can also be a unique string code if preferred over UUID
  guildId         String
  createdByUserId String
  code            String    @unique // The unique, shareable code for the link
  maxUses         Int? // Null for unlimited uses
  currentUses     Int       @default(0)
  expiresAt       DateTime? // Null for no expiration
  revokedAt       DateTime? // Timestamp if the link was manually revoked
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  guild         Guild @relation("LinkForGuild", fields: [guildId], references: [id], onDelete: Cascade)
  createdByUser User  @relation("LinkCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([createdByUserId])
  @@index([code])
}

model GuildJoinRequest {
  id               String                 @id @default(uuid())
  guildId          String
  userId           String // User requesting to join
  message          String?                @db.Text // Optional message from the user
  status           GuildJoinRequestStatus @default(PENDING)
  reviewedByUserId String? // Admin/Owner who reviewed the request
  reviewedAt       DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  guild          Guild @relation("RequestToGuild", fields: [guildId], references: [id], onDelete: Cascade)
  requestingUser User  @relation("Requester", fields: [userId], references: [id], onDelete: Cascade)
  reviewedByUser User? @relation("Reviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([guildId, userId]) // User can only have one pending request per guild
  @@index([guildId])
  @@index([userId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- CLUSTER INVITATION & JOIN REQUEST SYSTEM ---

model ClusterDirectInvitation {
  id              String                        @id @default(uuid())
  clusterId       String // The cluster sending the invitation
  invitedByUserId String // User (cluster admin) who sent the invitation
  targetGuildId   String // The guild being invited
  status          ClusterDirectInvitationStatus @default(PENDING)
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime? // Optional: for invitations that have a time limit

  invitingCluster Cluster @relation("InvitingCluster", fields: [clusterId], references: [id], onDelete: Cascade)
  invitedByUser   User    @relation("ClusterInviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetGuild     Guild   @relation("TargetGuildForClusterInvitation", fields: [targetGuildId], references: [id], onDelete: Cascade)

  @@unique([clusterId, targetGuildId], name: "uniqueClusterToGuildInvitation")
  @@index([clusterId])
  @@index([invitedByUserId])
  @@index([targetGuildId])
  @@index([status])
}

model ClusterJoinRequest {
  id                String                   @id @default(uuid())
  clusterId         String // The cluster being requested to join
  requestingGuildId String // The guild making the request
  requestedByUserId String // User from the requesting guild who initiated the request
  message           String?                  @db.Text
  status            ClusterJoinRequestStatus @default(PENDING)
  reviewedByUserId  String? // User (cluster admin) who reviewed the request
  reviewedAt        DateTime?
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt

  targetCluster   Cluster @relation("TargetClusterForJoinRequest", fields: [clusterId], references: [id], onDelete: Cascade)
  requestingGuild Guild   @relation("RequestingGuildForClusterJoin", fields: [requestingGuildId], references: [id], onDelete: Cascade)
  requestedByUser User    @relation("ClusterJoinRequester", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  reviewedByUser  User?   @relation("ClusterJoinRequestReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  @@unique([clusterId, requestingGuildId], name: "uniqueGuildToClusterJoinRequest")
  @@index([clusterId])
  @@index([requestingGuildId])
  @@index([requestedByUserId])
  @@index([status])
  @@index([reviewedByUserId])
}

// --- GUILD RELATIONSHIP PROPOSAL SYSTEM ---

model GuildRelationshipProposal {
  id                   String                     @id @default(uuid())
  proposingGuildId     String
  targetGuildId        String
  proposedType         RelationshipType
  status               RelationshipProposalStatus @default(PENDING)
  messageFromProposer  String?                    @db.Text
  messageFromResponder String?                    @db.Text
  proposedByUserId     String
  resolvedByUserId     String?
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  expiresAt            DateTime?

  proposingGuild Guild @relation("ProposingGuildForRelationship", fields: [proposingGuildId], references: [id], onDelete: Cascade)
  targetGuild    Guild @relation("TargetGuildForRelationship", fields: [targetGuildId], references: [id], onDelete: Cascade)
  proposedByUser User  @relation("ProposedByUser", fields: [proposedByUserId], references: [id], onDelete: Cascade) // Relation name to match User model
  resolvedByUser User? @relation("ResolvedByUser", fields: [resolvedByUserId], references: [id], onDelete: SetNull) // Relation name to match User model

  @@unique([proposingGuildId, targetGuildId, proposedType, status], name: "unique_pending_guild_relationship_proposal") // Prevents identical pending proposals
  @@index([proposingGuildId])
  @@index([targetGuildId])
  @@index([status])
  @@index([proposedByUserId])
  @@index([resolvedByUserId])
}

// +++ NEW MODEL +++
model UploadedAsset {
  id                 String    @id @default(cuid())
  uploaderId         String?   // User who uploaded it (nullable if system can upload e.g. default assets)
  uploader           User?     @relation("UserUploadedAssets", fields: [uploaderId], references: [id], onDelete: SetNull)
  
  originalFilename   String?
  mimeType           String    // e.g., "image/png", "image/jpeg", "image/svg+xml"
  sizeBytes          Int       // Size AFTER Sharp.js processing (if applicable)
  
  // The publicly accessible URL (e.g., /uploads/images/... or S3/R2 URL, or CDN URL)
  // This is what frontends will use in <img> tags or CSS.
  hostedUrl          String    @unique 
  
  // The key/filename within the specific storage system (e.g., local filename, S3/R2 object key).
  // Used by the backend storage service to locate/delete the actual file.
  storageIdentifier  String    @unique 
  
  assetType          String    // For categorization, e.g., "BADGE_TEMPLATE_IMAGE", "USER_AVATAR", "BADGE_ICON_FG"
  description        String?   // Optional description of the asset
  
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Example: If you wanted a direct one-to-one for User Avatars instead of User.avatar storing the hostedUrl
  // userAsAvatar       User?     @relation("UserAvatarAsset")

  @@index([uploaderId])
  @@index([assetType])
  @@index([hostedUrl]) // If you need to look up assets by their public URL
}
// +++ END NEW MODEL +++

// +++ NEW MODEL for Predefined System Icons +++
model SystemIcon {
  id           String  @id @default(cuid()) // Or a unique key like "icon_star_filled"
  name         String  @unique              // e.g., "Star Filled", "Shield", "Heart Outline"
  category     String?                     // e.g., "Achievements", "Interface", "Common"
  svgContent   String?                     // If you store SVG markup directly (ensure sanitization on render)
  assetId      String? @unique             // Optional: Link to an UploadedAsset if it also has a raster version or is managed there
  asset        UploadedAsset? @relation(fields: [assetId], references: [id], onDelete: SetNull) // If linked to an UploadedAsset
  isAvailable  Boolean @default(true)      // If you want to enable/disable icons from the predefined list
  description  String?                     // Optional description or usage hint
  tags         String[]                    // For searchability, e.g., ["favorite", "rating", "achievement"]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // If you were to use the full relational approach for BadgeDisplayConfig,
  // this icon could be linked there. For JSON approach, config refers to SystemIcon.id/name.
  // badgeDisplayConfigsAsForeground SystemIconForeground[]

  @@index([name])
  @@index([category])
  @@index([isAvailable])
}
// +++ END NEW MODEL +++
