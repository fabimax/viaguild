# Badge System Refactor - Implementation Plan

This document outlines the step-by-step plan to implement the badge system refactor, as detailed in `Documentation For LLMs/Badge System Refactor Plan.md`.

## Phase 1: Backend - Schema and Core Logic

**Goal:** Update the database schema and the core backend services to support the new badge model where users and guilds can be both givers and receivers.

1.  **Backup Database (Important!)**: Before making any schema changes, ensure you have a reliable backup of your development database.

2.  **Update Prisma Schema (`server/prisma/schema.prisma`):**
    *   Modify the `BadgeInstance` model:
        *   Add `userGiverId: String?`, `guildGiverId: String?`
        *   Add `userReceiverId: String?`, `guildReceiverId: String?`
        *   Add `guildAssignmentDetailsId: String? @unique`
        *   Update relations for givers and receivers to use these new fields and distinct relation names (e.g., `UserGivenBadges`, `GuildReceivedBadges`).
        *   Remove old `giverId` and `receiverId` fields.
    *   Create the new `GuildAssignmentDetails` model with its fields and relation to `BadgeInstance`.
    *   Update `User` and `Guild` models with the new relations for badges given/received.
    *   (Note: `UserBadgeItem` and `GuildBadgeItem` linking to `BadgeInstance` likely don't need structural schema changes, but the `BadgeInstance` they link *to* is changing.)

3.  **Generate Prisma Client:**
    *   Run `npx prisma generate` to update the Prisma Client based on the new schema.

4.  **Create Database Migration:**
    *   Run `npx prisma migrate dev --name refactor-badge-system`.
    *   **Carefully review the generated SQL migration script.**
        *   Pay attention to how Prisma handles the removal of old columns and the addition of new ones, especially regarding nullability and defaults.
        *   **Data Transformation (if applicable):** If you have existing `BadgeInstance` data, the migration script generated by Prisma might just drop old columns and add new ones, leading to data loss for existing instances. You may need to:
            *   Edit the migration script to first copy data from `giverId` to `userGiverId` and `receiverId` to `userReceiverId` before dropping the old columns.
            *   Alternatively, write a separate data migration script (e.g., a TypeScript script using Prisma Client) to run *after* the schema migration, to transform old data into the new structure.
        *   **CHECK Constraints**: If your database (e.g., PostgreSQL) supports it, consider adding `CHECK` constraints manually to the SQL migration to enforce:
            *   Exactly one of `userGiverId` or `guildGiverId` is non-null.
            *   Exactly one of `userReceiverId` or `guildReceiverId` is non-null.
            *   `guildAssignmentDetailsId` can only be non-null if `guildGiverId` is non-null.
            *(Prisma doesn't manage these directly in `schema.prisma`)*.
    *   Apply the migration.

5.  **Update Seed Files (`server/prisma/seeds/*.ts` and `server/prisma/seed.ts`):**
    *   **`badges.ts` (`seedBadges` function):**
        *   Modify the creation of `BadgeInstance` records to use the new `userGiverId`/`guildGiverId` and `userReceiverId`/`guildReceiverId` fields.
        *   Decide on a strategy for seeding givers/receivers (e.g., some user-to-user, some user-to-guild, some guild-to-user, some guild-to-guild).
        *   If seeding guild-given badges, optionally create and link `GuildAssignmentDetails` records.
    *   **`badgeCases.ts` (`seedBadgeCases` function):**
        *   Update logic to reflect that `GuildBadgeCase` should now showcase badges *received by* the guild. This means `GuildBadgeItem` records will link to `BadgeInstance`s where `guildReceiverId` matches the guild of the badge case.
        *   Ensure `UserBadgeItem` links to `BadgeInstance`s where `userReceiverId` matches the user of the badge case.
    *   Run `npx prisma db seed` to test the updated seed scripts. Debug and iterate until seeding is successful and data looks correct.

6.  **Implement/Update Backend Badge Service (e.g., `server/src/services/badge.service.js`):**
    *   If `badge.service.js` doesn't exist, create it. This service will encapsulate all business logic related to badge creation, assignment, and retrieval according to the new schema.
    *   **Badge Creation/Assignment Logic:**
        *   Implement functions to create/assign badges, accepting parameters for giver type (user/guild) and receiver type (user/guild).
        *   Ensure these functions correctly populate the new fields in `BadgeInstance`.
        *   Implement logic to create and link `GuildAssignmentDetails` if a guild is the giver and provides relevant details.
    *   **Badge Fetching Logic:**
        *   Implement functions to fetch badges for various contexts (e.g., for user/guild badge cases, for specific queries).
        *   Ensure these functions can retrieve and include the `BadgeTemplate` details (name, image, etc.) and, if applicable, `GuildAssignmentDetails`.
    *   **Integration with other services:** Existing services (like `guild.service.js` if it previously handled badge data for guild profiles) will need to be updated to call this new badge service for badge-related information, or their badge-related logic must be refactored to align with the new schema (e.g., fetching received badges for a guild).
    *   **Permissions**: Implement or update permission logic related to badge management.

7.  **Implement/Update Backend Badge API Endpoints/Controllers (e.g., `server/src/controllers/badge.controller.js`):**
    *   If `badge.controller.js` doesn't exist, create it. This controller will handle HTTP requests related to badges.
    *   Define routes (e.g., in your main Express router or a dedicated badge router) that map to the controller's methods.
    *   **Badge Assignment Endpoint:**
        *   Implement an endpoint (e.g., `POST /api/badges/assign`) that calls the badge service to assign a badge. It should accept parameters reflecting giver type, receiver type, template ID, and any guild-specific assignment details.
    *   **Badge Retrieval Endpoints:**
        *   Update or create endpoints for fetching badge data. For instance, the existing `GET /api/guilds/:id/badges` endpoint (likely in `guild.controller.js`) will need to be modified. Its corresponding service logic in `guild.service.js` should now fetch `BadgeInstance` records where the specified guild is the *receiver*, potentially by calling the new `badge.service.js`.
        *   Create new endpoints if needed for other badge queries (e.g., badges given by a user/guild).
    *   Ensure error handling and validation are robust.

8.  **Unit/Integration Tests (Backend):** Create or update backend tests to cover the new badge service and controller logic, including different giver/receiver combinations and guild assignment details.

## Phase 2: Frontend - Adapting to New Badge Logic

**Goal:** Update the frontend to correctly display and interact with the refactored badge system.

1.  **Update `GuildOverviewPage.jsx` (`client/src/pages/GuildOverviewPage.jsx`):**
    *   **Badge Showcase Data Fetching:** Modify the `useEffect` hook that fetches `/api/guilds/${id}/badges`. The response data will now be a list of `BadgeInstance` objects (where the guild is the receiver), not `BadgeTemplate`s.
    *   **Badge Showcase State:** Adjust the `badges` state (e.g., `badges.badgeCase.badges` or a similar structure) to store the new `BadgeInstance` data.
    *   **Badge Rendering (`renderBadgeShape` and mapping):**
        *   When mapping over the received badges for display, remember that each item is now a `BadgeInstance`.
        *   The `renderBadgeShape` function will need to access visual properties via `badge.template.imageUrl`, `badge.template.name`, `badge.template.shapeType`, `badge.template.borderColor`, etc.
        *   Update any displayed text (e.g., change "No badges created by this guild yet" to "This guild has not received any badges yet").
        *   Decide how to display information about the *giver* of each badge if desired (e.g., "Given by User X" or "Awarded by Guild Y").
    *   **"Show More/Less" Logic**: Ensure this still works correctly with the new data structure.

2.  **Update User Profile Page (if it displays user-received badges):**
    *   Similar to the Guild Overview, update how badges are fetched and displayed for a user's badge case.
    *   The API endpoint for user badges will need to provide `BadgeInstance` records where the user is the receiver.

3.  **Update Badge Assignment UI (if it exists or is planned):**
    *   If there's a UI for users or guilds to assign badges, it will need to be updated to allow selection of:
        *   The badge template to assign.
        *   The receiver (either a user or a guild).
        *   If a guild is assigning, potentially fields for `GuildAssignmentDetails`.

4.  **Global Types/Interfaces (Frontend):** Update any TypeScript interfaces or PropTypes used on the frontend to represent badge data to match the new backend structures.

5.  **End-to-End Testing:** Test the complete flow:
    *   Seeding data.
    *   Assigning badges (user-to-user, user-to-guild, guild-to-user, guild-to-guild) via API (and UI if built).
    *   Displaying badges correctly in the Guild Overview page's badge showcase.
    *   Displaying badges correctly in User Profile badge cases.

## Phase 3: Refinements and Future Work (Post-MVP)

*   Implement UI for guild-specific badge assignment mechanisms (e.g., voting).
*   Enhance API endpoints for more complex badge queries if needed.
*   Refine database CHECK constraints or add more robust application-level validation for the giver/receiver exclusivity.

This phased approach should help manage the complexity of the changes. Prioritize getting the backend schema and core services correct before moving extensively to the frontend adaptations.

---

## Appendix: Potentially New Files/Directories

Based on the assumption that dedicated badge services and controllers might not yet exist, this plan may require the creation of the following:

*   **Backend Service:**
    *   `server/src/services/badge.service.js` (if not already existing and dedicated to badge logic)
*   **Backend Controller:**
    *   `server/src/controllers/badge.controller.js` (if not already existing and dedicated to badge logic)
*   **Backend Routes:**
    *   Potentially a new route file like `server/src/routes/badge.routes.js` if you centralize badge-related routes, or modifications to existing route files to include routes handled by `badge.controller.js`.
*   **Backend Tests:**
    *   New test files for the badge service, e.g., `server/src/services/__tests__/badge.service.test.js` or similar.
    *   New test files for the badge controller/endpoints, e.g., `server/src/controllers/__tests__/badge.controller.test.js` or integration tests for badge APIs.

**Note:** If badge-related logic is currently embedded within other files (e.g., `guild.service.js`), the effort might involve refactoring and moving that logic into these new dedicated files rather than creation from scratch. The exact file creation will depend on the current state of the codebase. 